<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>预言成功！new必应来了！以及python接入OpenAI API</title>
      <link href="/2023/02/17/python%E6%8E%A5%E5%85%A5OpenAI-API/"/>
      <url>/2023/02/17/python%E6%8E%A5%E5%85%A5OpenAI-API/</url>
      
        <content type="html"><![CDATA[<p>两个月前我分享了chatgpt的注册和使用后预言了是否能颠覆Google后，没想到刚刚过去60天，微软就推出了整合chatgpt和必应的new必应搜索，这一措施让微软一洗颓势，从今后这条可能最重要的赛道上领先于Google和其他任何公司。本来今天我想聊一下新必应的应用，结果由于申请的候补一直没通过，所以就先分享一下如何在python接入openai的api，今后有很多应用会基于这个进行开发。</p><h2 id="生成api-key"><a href="#生成api-key" class="headerlink" title="生成api key"></a>生成api key</h2><p>首先注册openai就没必要说了，如果没有注册的可以看我12月8号发的文章，这里提醒下现在注册和使用条件变严格了，有些节点或者手机号并不能成功，需要大家多寻找可用的节点和手机号。<br>第一步我们访问<a href="https://platform.openai.com/account/api-keys">https://platform.openai.com/account/api-keys</a> 这个网站，然后点击create new secret key生成密匙，<br><img src="/img/230217/1.png" alt="这是图片" title="Magic Gardens"><br>这里要注意生成的key下次就看不了，我建议复制保存到电脑上，要不然下次又要重新生成一个key。</p><h2 id="python接入api"><a href="#python接入api" class="headerlink" title="python接入api"></a>python接入api</h2><p>openai官方给了node和python两种方式接入，这里为了演示方便，选择用python来接入，<br>第一步安装openai包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install openai</span><br></pre></td></tr></table></figure><h2 id="文本类型"><a href="#文本类型" class="headerlink" title="文本类型"></a>文本类型</h2><p>openai官方有很多模型来训练，我们熟知的chatgpt就是使用gpt3.5模型来训练，我们这里选择三种常见的模型文本、代码和图片来进行演示，这里我们可以用中文和英文来进行询问，但是中文返回结果要进行序列化所以我们暂时使用英文。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import openai</span><br><span class="line">openai.api_key &#x3D; &quot;你的key&quot;</span><br><span class="line">prompt &#x3D;&quot;&quot;&quot;</span><br><span class="line">Does chatgpt belong to openai? Yes or no</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">response &#x3D; openai.Completion.create( model&#x3D;&quot;text-davinci-003&quot;, prompt&#x3D;prompt, max_tokens&#x3D;100, temperature&#x3D;0  )</span><br><span class="line">print(response)</span><br></pre></td></tr></table></figure><p>下面是返回的部分内容：<br><img src="/img/230217/2.png" alt="这是图片" title="Magic Gardens"><br>这里的text就是返回的结果，但是不知道为什么他说chatgpt不属于openai😛<br>这里我解释下发送create的参数：<br>model：使用的模型类别<br>prompt：你要问的问题<br>max_token：完成的最大token数量<br>temperature：回答问题的程度，越接近0越标准，接近于1越开放</p><h2 id="代码类型"><a href="#代码类型" class="headerlink" title="代码类型"></a>代码类型</h2><p>代码类型使用codex模型来查询，这里我们输入问题是用js写一个验证手机号的正则表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import openai</span><br><span class="line">openai.api_key &#x3D; &quot;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&quot;</span><br><span class="line">prompt &#x3D;&quot;Write a regular expression in javascript that validates the phone number&quot;</span><br><span class="line">response &#x3D; openai.Completion.create(</span><br><span class="line">  model&#x3D;&quot;code-davinci-002&quot;,</span><br><span class="line">  prompt&#x3D;prompt,</span><br><span class="line">  temperature&#x3D;0,</span><br><span class="line">  max_tokens&#x3D;256,</span><br><span class="line">  top_p&#x3D;1,</span><br><span class="line">  frequency_penalty&#x3D;0,</span><br><span class="line">  presence_penalty&#x3D;0)</span><br><span class="line">print(response)</span><br></pre></td></tr></table></figure><p>下面是返回结果：<br>      “text”: “.\n\nThe phone number should be in the following format:\n\n(123) 456-7890\n\nThe number should start with an opening parenthesis, followed by 3 digits, a closing parenthesis, a space, 3 digits, a hyphen, and 4 digits.\n\nThe phone number can optionally have an extension, which consists of a space, the letter x, and 3 or more digits.\n\nExamples:\n\n(123) 456-7890\n\n(123) 456-7890 x1234\n\n(123) 456-7890 ext1234\n\n(123) 456-7890 ext.1234\n\n*/\n\n// Write your code here\n\nlet phoneNumber = /^\(\d{3}\)\s\d{3}-\d{4}(?:\sx\d{3,})?$/;\n\n// Tests\n\nfor (let str of [&quot;(123) 456-7890&quot;, &quot;(123) 456-7890 x1234&quot;, &quot;(123) 456-7890 ext1234&quot;, &quot;(123) 456-7890 ext.1234&quot;]) {\n  if”</p><h2 id="图片类型"><a href="#图片类型" class="headerlink" title="图片类型"></a>图片类型</h2><p>图片类型我们使用dall-e模型来生成，我输入的内容是一只猫和一条狗互相玩耍的照片，输入限制条件越多越容易得到想要的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import openai</span><br><span class="line">openai.api_key &#x3D; &quot;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&quot;</span><br><span class="line">response &#x3D; openai.Image.create(</span><br><span class="line">  prompt&#x3D;&quot;A cat and a dog play with each other&quot;,</span><br><span class="line">  n&#x3D;1,</span><br><span class="line">  size&#x3D;&quot;1024x1024&quot;</span><br><span class="line">)</span><br><span class="line">image_url &#x3D; response[&#39;data&#39;][0][&#39;url&#39;]</span><br><span class="line">print(image_url)</span><br></pre></td></tr></table></figure><p>下面是我得到的图片：<br><img src="/img/230217/3.png" alt="这是图片" title="Magic Gardens"><br>参数size可以调整你想要图片的大小真是太方便了</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上只是openai的api最简单实用方式，如果想要深入了解可以访问官方文档 <a href="https://platform.openai.com/docs/api-reference/edits">https://platform.openai.com/docs/api-reference/edits</a> 来进行学习，当然别人也不是做慈善的，每个人有一定的免费额度，超过了就要进行付费，当然我们平时学习这点额度肯定也是够的，相信过不了多久国内大厂也会有相关的api开放给我们使用，我的建议是好好学习这方面的知识毕竟很有可能是下一个风口。</p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenAI </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用charles抓取ios的app网络请求包</title>
      <link href="/2023/01/04/%E5%88%A9%E7%94%A8charles%E6%8A%93%E5%8F%96ios%E7%9A%84app%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%8C%85/"/>
      <url>/2023/01/04/%E5%88%A9%E7%94%A8charles%E6%8A%93%E5%8F%96ios%E7%9A%84app%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么选择charles"><a href="#为什么选择charles" class="headerlink" title="为什么选择charles"></a>为什么选择charles</h2><p>相信大家在用windows抓包的时候经常用到fiddler进行抓包，fiddler虽然好用但是也有个弊端就是跨平台支持不好，当我换成mac的时候需要抓包就了解到charles这个跨windows、macos、linux三端的抓包工具，接下来是我在用这个软件时遇到的问题和解决方法。</p><h2 id="1-下载charles并配置代理"><a href="#1-下载charles并配置代理" class="headerlink" title="1 下载charles并配置代理"></a>1 下载charles并配置代理</h2><p>到charles官网下载最新的dmg文件，查看当前连的局域网的ip地址，打开iphone设置连接同一个wifi，代理设置手动并填入mac的局域网ip，端口号默认为charles的8888。<br><img src="/img/230104/1.jpeg" alt="这是图片" title="Magic Gardens"> </p><h2 id="2-下载mac和iphone相关的ca证书"><a href="#2-下载mac和iphone相关的ca证书" class="headerlink" title="2 下载mac和iphone相关的ca证书"></a>2 下载mac和iphone相关的ca证书</h2><p>mac打开charles选择菜单栏的Help-SSL Proxying-Install Charles Root Certificate,如图所示<br><img src="/img/230104/2.png" alt="这是图片" title="Magic Gardens"><br>搜索charles双击打开证书设置加密套接字协议层为始终信任<br><img src="/img/230104/3.png" alt="这是图片" title="Magic Gardens"><br>然后在iphone上打开safari浏览器输入地址：chls.pro/ssl下载证书描述文件，打开设置安装并信任证书。</p><h2 id="3-配置-SSL-Proxying-Setting"><a href="#3-配置-SSL-Proxying-Setting" class="headerlink" title="3 配置 SSL Proxying Setting"></a>3 配置 SSL Proxying Setting</h2><p>菜单栏点击Proxy-SSL Proxying Setting，在Host输入*，Port输入443来抓取https请求<br><img src="/img/230104/4.png" alt="这是图片" title="Magic Gardens"> </p><h2 id="4-总结or乱码"><a href="#4-总结or乱码" class="headerlink" title="4 总结or乱码"></a>4 总结or乱码</h2><p>接下来我们可以打开iphone的app就行操作就会抓到https的请求包了，有可能会出现乱码的情况，原因可能是mac没下载ca证书或者没配置https代理。<br><img src="/img/230104/5.png" alt="这是图片" title="Magic Gardens"> </p>]]></content>
      
      
      <categories>
          
          <category> 抓包 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 抓包 </tag>
            
            <tag> charles </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenAI出的ChatGPT注册以及使用,能颠覆Google吗</title>
      <link href="/2022/12/08/OpenAI%E5%87%BA%E7%9A%84ChatGPT%E6%B3%A8%E5%86%8C%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8-%E8%83%BD%E9%A2%A0%E8%A6%86Google%E5%90%97/"/>
      <url>/2022/12/08/OpenAI%E5%87%BA%E7%9A%84ChatGPT%E6%B3%A8%E5%86%8C%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8-%E8%83%BD%E9%A2%A0%E8%A6%86Google%E5%90%97/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>12月1号OpenAI推出了ChatGPT这个AI智能聊天机器人，号称能回答你所有的问题，甚至可以根据你的需求来写代码，我也第一时间注册并使用了，接下来我分享一下过程和使用心得。  </p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>基础条件要能访问Google（懂得都懂😁）</li><li>一个邮箱最好是外国邮箱这里推荐gmail（国内邮箱不确定是否能用）</li><li>一个外国手机号（这里推荐虚拟手机号）<h2 id="注册sms并充值"><a href="#注册sms并充值" class="headerlink" title="注册sms并充值"></a>注册sms并充值</h2></li><li>1 注册虚拟手机号平台 <a href="https://sms-activate.org/cn">https://sms-activate.org/cn</a></li><li>2 进行充值<br><img src="/img/1208/1.png" alt="这是图片" title="Magic Gardens"><br>这里我们选择充值0.2美元为了进行购买最便宜的号码。</li><li>3 注册OpenAI <a href="https://beta.openai.com/signup">https://beta.openai.com/signup</a><br><img src="/img/1208/2.png" alt="这是图片" title="Magic Gardens"><br>这里输入你的邮箱然后输入密码，之后OpenAI会给你的邮箱发一个消息你去邮箱里确认后跳转下一步。</li><li>4 打开sms网站搜索OpenAI然后选择印度、印度尼西亚、巴西其中一个（这几个基本可以）<br><img src="/img/1208/3.png" alt="这是图片" title="Magic Gardens"> </li><li>5 在OpenAI注册页面继续点下一步输入你购买的手机号。<br><img src="/img/1208/5.png" alt="这是图片" title="Magic Gardens"> </li><li>6 接收验证码并填入<br><img src="/img/1208/4.png" alt="这是图片" title="Magic Gardens"><br>如果几分钟收不到验证码可以换一个国家的号码，20分钟内可以退掉。<h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2>现在我们可以登录访问 <a href="https://chat.openai.com/chat">https://chat.openai.com/chat</a>  。<h3 id="比如我们可以说用javascript写一个登录页面："><a href="#比如我们可以说用javascript写一个登录页面：" class="headerlink" title="比如我们可以说用javascript写一个登录页面："></a>比如我们可以说用javascript写一个登录页面：</h3><img src="/img/1208/6.png" alt="这是图片" title="Magic Gardens"> <h3 id="发现太简单了，我再输入leetcode中一道困难的题目："><a href="#发现太简单了，我再输入leetcode中一道困难的题目：" class="headerlink" title="发现太简单了，我再输入leetcode中一道困难的题目："></a>发现太简单了，我再输入leetcode中一道困难的题目：</h3><img src="/img/1208/7.png" alt="这是图片" title="Magic Gardens"><br>复制输入leetcode运行成功而且他不光能给出代码还能写出理解改怎么实现和注释！<h3 id="不光代码，你也可以输入任何问题只要他能理解"><a href="#不光代码，你也可以输入任何问题只要他能理解" class="headerlink" title="不光代码，你也可以输入任何问题只要他能理解"></a>不光代码，你也可以输入任何问题只要他能理解</h3><img src="/img/1208/8.png" alt="这是图片" title="Magic Gardens"> <h2 id="使用感受"><a href="#使用感受" class="headerlink" title="使用感受"></a>使用感受</h2>使用了了一段时间后我理解这个东西就像一个AI版的Google，在代码层面和当初的copilot差不多，但是多了其他场景甚至是任何方面的问题都能回答，虽然这个AI助手现在可能对中文的问题理解还不够彻底，但我相信再过一段时间的训练也许真能回答我们的所有问题。<br>在我看来这个软件应该不会取代Google搜索，会成为Google搜索的AI版，会让一部分有条件的人使用，毕竟境内不太可能放开这种限制而且我预计正式版应该也会收费。 </li></ul><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>刚刚发现vscode上已经有人写了基于ChatGPT插件可以实现AI翻译和重构代码，相信马上官方和jetbrains也会跟上。</p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenAI </tag>
            
            <tag> ChatGPT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS实现防止按钮重复点击</title>
      <link href="/2022/11/23/CSS%E5%AE%9E%E7%8E%B0%E9%98%B2%E6%AD%A2%E6%8C%89%E9%92%AE%E9%87%8D%E5%A4%8D%E7%82%B9%E5%87%BB/"/>
      <url>/2022/11/23/CSS%E5%AE%9E%E7%8E%B0%E9%98%B2%E6%AD%A2%E6%8C%89%E9%92%AE%E9%87%8D%E5%A4%8D%E7%82%B9%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们在工作中经常遇到需要按钮做防止重复点击的需求，以前我们实现这个节流的功能会用节流函数或者使用第三方库来快速实现，但是现在项目中一般使用按钮loading或者全局loading来实现这个功能，这也让我们停止思考了还可以用其他方式来实现防止停止点击，实际上使用css的几个属性就能快速做到这个效果。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>首先我们要思考下css怎么触发类似js的click事件呢？我们日常生活中可能用到的伪类可能是hover这种，但是实际上css有个active伪类可以在按钮点击的时候更新样式，然后依靠什么属性来禁止点击呢，答案是pointer-events这个属性，当它为none时可以使元素不成为鼠标点击事件，最后还有一个问题是怎么控制间隔时间呢，我想到了利用动画animation。</p><h2 id="具体实现方式"><a href="#具体实现方式" class="headerlink" title="具体实现方式"></a>具体实现方式</h2><p>我们可以利用active伪类来实现点击按钮时触发动画，然后设置动画的起点和终点的点击分别为可以点击auto和不可点击none，具体实现代码如下：    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">button&#123;</span><br><span class="line">  animation: throttle 2s step-end forwards;</span><br><span class="line">&#125;</span><br><span class="line">button:active&#123;</span><br><span class="line">  animation: none;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes throttle &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    pointer-events: none;</span><br><span class="line">  &#125;</span><br><span class="line">  to &#123;</span><br><span class="line">    pointer-events: all;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然我们工作中可能不会用这个方式来防止重复点击，但这对我们理解css可能会有一些帮助，也在我们烦杂的生活中增添一丝乐趣。</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> click </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Quark Design和Web Components</title>
      <link href="/2022/11/14/Quark-Design%E5%92%8CWeb-Components/"/>
      <url>/2022/11/14/Quark-Design%E5%92%8CWeb-Components/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几天哈罗单车前端团队开源了Quark Design组件库，号称是下一代的前端组件库以至于可以在任何框架或原生js中使用。<br>看到这的时候我以为是类似于Ant Desigen of Vue 和Ant Design合起来然后按照项目框架分别引用😂，然后仔细一看好像是真的支持任何框架依靠Web Components来实现，关于Web Components我之前只是听说过而一直没怎么去了解，趁这个框架我去学习了Web Components。</p><h2 id="Web-Components是什么"><a href="#Web-Components是什么" class="headerlink" title="Web Components是什么"></a>Web Components是什么</h2><p>Web Components与React、Vue等框架中的组件类似，其实在Vue中也采用了很多基于Web Components的设计。这是一个可复用的UI构建模块，封装了所有渲染所需要的HTML、CSS以及基于Javascript的逻辑。最大的区别是，它不依赖于特定的JavaScript框架，而是利用浏览器原生提供的技术，这样你的Web组件就与框架无关了。</p><h2 id="Web-Components的主要内容"><a href="#Web-Components的主要内容" class="headerlink" title="Web Components的主要内容"></a>Web Components的主要内容</h2><p>Web Components的主要内容如下：  </p><ul><li>Custom Elements：原生提供的API，用于可自定义Custom Elements和行为。</li><li>Shadow DOM：原生提供的API，用于封装与主文档DOM隔离的私有DOM，不受外部DOM的样式和行为的影响。</li><li>Templates</li><li>Attributes</li><li>Slots</li><li>Life cycle methods</li></ul><h2 id="Custom-Elements"><a href="#Custom-Elements" class="headerlink" title="Custom Elements"></a>Custom Elements</h2><p>Custom Elements是Web Components中的一个重要特性，可以提供给开发者将html的功能封装为自定义标签，方便进行复用。也就是说，Custom Elements本质上是用户用于实现在html中有效使用的，类似div、button等自定义标签。最大区别在于，自定义标签有着自己的模板、行为和标签名称，通过Javascript的API实现的。<br>Custom Elements总是使用连字符-进行自定义标签的标识，即one-button，各大浏览器公司达成公司不在创建任何新的标签元素，来防止元素冲突。熟悉vue框架的开发者应该知道，在vue中的自定义组件命令有OneButton或one-button这种结构，官方推荐的是one-button这种使用方式。<br>我们来简单实现一下一个自定义标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; one-button.js</span><br><span class="line">&#x2F;&#x2F; 1、创建自定义组件的类</span><br><span class="line">class OneButton extends HTMLElement&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        super()</span><br><span class="line">        &#x2F;&#x2F; 2、创建组件内容</span><br><span class="line">        this.innerHTML &#x3D; &#96;&lt;button&gt;hello onechuan&lt;&#x2F;button&gt;&#96;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3、进行自定义组件的注册</span><br><span class="line">customElements.define(&quot;one-button&quot;, OneButton)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; index.html</span><br><span class="line">&#x2F;&#x2F; 4、html中进行使用</span><br><span class="line">&lt;one-button&gt;&lt;&#x2F;one-button&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;.&#x2F;one-button.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="Shadow-DOM"><a href="#Shadow-DOM" class="headerlink" title="Shadow DOM"></a>Shadow DOM</h2><p>Shadow DOM与原生DOM的区别就是用户自定义封装的DOM，本质上还是DOM元素。不同的是，Shadow DOM可以将自定义的DOM片段与其他DOM进行隔离，可以实现样式不受外部DOM的影响，类似与使用iframe内嵌了一个html。也正是Shadow DOM的存在，能够进行DOM隔离、实现独立的组件王国，使得自定义组件跨域框架的约束，不再耦合，确保在任何无框架和任何框架中正常使用。<br><img src="/img/1114/1.png" alt="这是图片" title="Magic Gardens"><br>Shadow DOM 并不是新生事物，在原生video标签中其实就有内置的Shadow DOM ，包含一系列的按钮和其他控制器等。而Web Components只不过是允许用户根据需要使用Shadow DOM来实现自定义标签。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; one-button.js</span><br><span class="line">&#x2F;&#x2F; 1、创建自定义组件的类</span><br><span class="line">class OneButton extends HTMLElement&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        super()</span><br><span class="line">        &#x2F;&#x2F; 2、创建shadow dom</span><br><span class="line">        this.attachShadow(&#123;mode: &#39;open&#39;&#125;)</span><br><span class="line">        this.shadowRoot.innerHTML &#x3D; &#96;&lt;button&gt;hello onechuan&lt;&#x2F;button&gt;&#96;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3、进行自定义组件的注册</span><br><span class="line">customElements.define(&quot;one-button&quot;, OneButton)</span><br></pre></td></tr></table></figure><p>在上面运行结果中，实现的展示效果是一样，但是渲染的dom节点却有所不同，在使用shadow dom实现的标签中会有#shadow-root字样标识。</p><h2 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h2><p>见到template模板，使用过vue框架的开发者就再熟悉不过了，template标签本身不会在html中进行立即渲染，而是用于对待使用的代码进行标记，在需要被使用的时候才会进行渲染。也正是因为template的特性，使得我们可以将一些可重复使用的代码用template进行组织，通过javascript获取它的引用，再添加到DOM中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;one-button&gt;&lt;&#x2F;one-button&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;button&gt;hello yichuan&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const template &#x3D; document.createElement(&quot;template&quot;)</span><br><span class="line">    template.innerHTML &#x3D; &#96;&lt;button&gt;hello onechuan&lt;&#x2F;button&gt;&#96;</span><br><span class="line">    &#x2F;&#x2F; 1、实现自定义组件的类</span><br><span class="line">    class OneButton extends HTMLElement&#123;</span><br><span class="line">        &#x2F;&#x2F; 2、定义自定义组件的内容</span><br><span class="line">        constructor()&#123;</span><br><span class="line">            super()</span><br><span class="line">            &#x2F;&#x2F; 2-1、创建影子DOM</span><br><span class="line">            this.attachShadow(&#123;mode: &quot;open&quot;&#125;)</span><br><span class="line">            &#x2F;&#x2F; 2-2、设置影子DOM的内容</span><br><span class="line">            </span><br><span class="line">            this.shadowRoot.appendChild(template.content.cloneNode(true))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 3、注册自定义组件</span><br><span class="line">    customElements.define(&quot;one-button&quot;, OneButton)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>在上面代码片段中，可以看到在需要使用的时候将模板内容追加到shadow dom中，即模板内容不会立即被渲染，而是在被调用后才会在页面进行渲染。</p><h2 id="Slots"><a href="#Slots" class="headerlink" title="Slots"></a>Slots</h2><p>插槽由其name属性标识，并且允许您在模板中定义占位符，当在标记中使用该元素时，该占位符可以填充所需的任何 HTML 标记片段，这个和Vue的slot差不多功能和实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;one-button&gt;</span><br><span class="line">    &lt;button&gt;hello yichuan&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;one-button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const template &#x3D; document.createElement(&quot;template&quot;)</span><br><span class="line">    template.innerHTML &#x3D; &#96;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;slot&gt;&lt;button&gt;hello onechuan&lt;&#x2F;button&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &#96;</span><br><span class="line">    class OneButton extends HTMLElement&#123;</span><br><span class="line">        constructor()&#123;</span><br><span class="line">            super()</span><br><span class="line">            this.attachShadow(&#123;mode:&quot;open&quot;&#125;)</span><br><span class="line">            this.shadowRoot.appendChild(template.content.cloneNode(true))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    customElements.define(&quot;one-button&quot;,OneButton)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="Life-Cycle-Methods"><a href="#Life-Cycle-Methods" class="headerlink" title="Life Cycle Methods"></a>Life Cycle Methods</h2><p>这里有三个方法分别是：</p><ul><li>connectedCallback：会在自定义组件插入DOM的首次渲染时调用一次。此时 shadow dom已经挂载到DOM树上，对此可以通过connectedCallback方法来访问shadow dom上的属性、子元素以及监听事件。倘若组件被移除或被移动，将会再次被调用。</li><li>attributeChangedCallback：监听custom element自身属性的增删改，当发生状态改变时调用此方法，在使用前必须在一个observedAttributes() 的静态方法中定义要观察的属性。该方法返回一个属性名称的数组。一旦observedAttributes返回了属性值数组，则attributeChangedCallback方法会在每次该属性变化时调用。</li><li>disconnectedCallback：当 custom element 从文档 DOM 中删除时，disconnectedCallback被调用。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Quark Design就是类似使用上述官方api实现的前端组件库，基本可以在任何项目中重复使用。我们在在构建Web Components时，步骤如下：</p><ul><li>首先，必须使用customElements.define()注册自定义元素</li><li>构造函数会调用，将节点添加到shadow dom中</li><li>然后，进行一次初始化，执行connectedCallback方法</li><li>当元素的属性被更新时，它的attributeChangedCallback()被触发</li><li>当一个事件从元素中被移除时，disconnectedCallback()方法被调用以清理事件监听器</li><li>shadow dom - 是DOM的一个封装版本，用于防止CSS泄露</li><li>Slots - 用于添加和访问自定义元素组件的子元素，也有一种特殊的方式来访问使用命名为Slot的子元素</li></ul><p>因为第一次了解Web Components这个内容，所以上述介绍很浅显也借鉴了许多文档资料，如有错误请指正。</p>]]></content>
      
      
      <categories>
          
          <category> Web Components </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web Components </tag>
            
            <tag> Quark Desigen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ant Desigin的tree控件使用过程中的一些踩坑及解决方法</title>
      <link href="/2022/10/26/Ant-Desigin%E7%9A%84tree%E6%8E%A7%E4%BB%B6%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B8%A9%E5%9D%91%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2022/10/26/Ant-Desigin%E7%9A%84tree%E6%8E%A7%E4%BB%B6%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B8%A9%E5%9D%91%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近一段时间因为工作太忙的原因导致一直没更新，今天空下来准备给大家分享一下这段时间内在用antd的tree组件在权限控制中的一些坑以及是如何解决的。</p><h2 id="权限设计思路"><a href="#权限设计思路" class="headerlink" title="权限设计思路"></a>权限设计思路</h2><p>一般的权限分配其实实现起来很简单，无非是利用tree组件接收数据和修改节点id，我做的这个权限接口返回了两个数据：一、有权限的id数组，二：权限的树形结构数据。<br>那到树形结构的数据后利用treeNode渲染树，具体实现如下  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">renderTreeNodes &#x3D; data &#x3D;&gt;</span><br><span class="line">    data.map(item &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">        if (item.children) &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;TreeNode title&#x3D;&#123;item.title&#125; key&#x3D;&#123;item.id&#125;&gt;</span><br><span class="line">            &#123;this.renderTreeNodes(item.children)&#125;</span><br><span class="line">            &lt;&#x2F;TreeNode&gt;</span><br><span class="line">        );</span><br><span class="line">        &#125;</span><br><span class="line">        return &lt;TreeNode title&#x3D;&#123;item.title&#125; key&#x3D;&#123;item.id&#125;&gt;&lt;&#x2F;TreeNode&gt;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后把需要勾选的id数组绑定checkKeys，最后设置勾选事件onCheck改变需要传给后端的数组id，树组件默认开启受控。<br>没错理论上权限功能已经全部实现，就是这么简单，但这需要后端去判断后续的所有逻辑，果然bug来了。</p><h2 id="勾选了子节点然后父节点没权限？"><a href="#勾选了子节点然后父节点没权限？" class="headerlink" title="勾选了子节点然后父节点没权限？"></a>勾选了子节点然后父节点没权限？</h2><p>一段时间后测试提出了bug：勾选了子菜单的权限但是没有选择全部子菜单后，父菜单的入口也没了，然后我查看了这个步骤后到底给后端传了什么数据，我发现如果只勾选部分子节点的话，父节点处于半勾选状态，这样子不会传入父节点的id，于是乎我和后端开始互相甩锅，我说你为啥不能判断他是否有父节点有的话给父节点加上权限，后端说你为什么不能把父节点传过来，最后我斗争失败决定前端来改。<br>解决方法就在onCheck事件中重新设置一个变量来push父节点的id：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">onCheck &#x3D; (checkedKeys,info)&#x3D;&gt;&#123;</span><br><span class="line">    const curKeys&#x3D;this.state.keys;</span><br><span class="line">    this.state.keys&#x3D;curKeys.concat(info.halfCheckedKeys);</span><br><span class="line">    let checkedKeysLast &#x3D;checkedKeys.concat(info.halfCheckedKeys)</span><br><span class="line">    this.setState(&#123;checkedKeysLast&#125;)</span><br><span class="line">    this.state.checkedKeysLast &#x3D;checkedKeysLast</span><br><span class="line">    this.setState(&#123; checkedKeys &#125;);</span><br><span class="line">    this.state.checkedKeys&#x3D;checkedKeys;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当选择子节点的时候把他的所有父节点也传入checkedKeysLast，但是注意不能改变渲染的原id数组，因为这样会全选，最后把新设置的数组传给接口。以为这样子就好了吗？马上发现了一个新bug。  </p><h2 id="所有权限都变成全选了！"><a href="#所有权限都变成全选了！" class="headerlink" title="所有权限都变成全选了！"></a>所有权限都变成全选了！</h2><p>然后我勾选了一个字节点后，发现的确父菜单可以访问了，但当我测试第二次的时候发现所有节点都被勾选了，但是实际上那些节点的功能都没有，我检查了一下发现是因为接口返回的数组都包含父节点，然后受控组件父节点选择的话会自动全部勾选子节点导致渲染问题。<br>我思考了下这个问题有两个解决思路，一个是改为非受控组件自己写check的实现方法，一个是去除原数组里的所有父节点。因为第一种方法改动太大而且可能会导致其他的bug所以实现第二种思路。</p><h2 id="最后解决方法"><a href="#最后解决方法" class="headerlink" title="最后解决方法"></a>最后解决方法</h2><p>我一开始准备循环checkedKeys的每一个id到treeData中判断是否是最底层的子节点然后进行删除，然后我发现这个方法太麻烦了，又想到了直接筛选treeData所有子节点然后和checkedKeys对比合并一个两个数组都有相同id的新数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const checkKeys &#x3D; this.state.checkedKeys.concat(this.props.checkedKeys);</span><br><span class="line">  const check &#x3D; (data, list) &#x3D;&gt; &#123;</span><br><span class="line">      data.forEach((item) &#x3D;&gt; &#123;</span><br><span class="line">          if (item.children &amp;&amp; item.children.length &gt; 0) &#123;</span><br><span class="line">              check(item.children, list);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              list.push(item.id);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      return list;</span><br><span class="line">  &#125;</span><br><span class="line">  const checkData &#x3D; (data) &#x3D;&gt; &#123;</span><br><span class="line">      const list &#x3D; [];</span><br><span class="line">      return check(data, list);</span><br><span class="line">  &#125;;</span><br><span class="line">  let sonCheckKeys &#x3D;checkData(this.state.treeData)</span><br><span class="line">  const resultValue &#x3D;(arr1,arr2) &#x3D;&gt;&#123;</span><br><span class="line">      console.log(arr1,arr2)</span><br><span class="line">      let newArr &#x3D; arr1.filter(t &#x3D;&gt; arr2.includes(t));</span><br><span class="line">      return newArr;</span><br><span class="line">  &#125;</span><br><span class="line">  const checkKeysFin &#x3D;resultValue(checkKeys,sonCheckKeys)</span><br><span class="line">  this.state.checkedKeys &#x3D;checkKeysFin</span><br><span class="line">  this.setState(&#123;checkKeys:checkKeysFin&#125;)</span><br></pre></td></tr></table></figure><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>其实这种bug前后端都可以改，就看你能不能让对方退步了。</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Antd </tag>
            
            <tag> React </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Vue3中实现React Hooks</title>
      <link href="/2022/08/25/%E5%9C%A8Vue3%E4%B8%AD%E5%AE%9E%E7%8E%B0React-Hooks/"/>
      <url>/2022/08/25/%E5%9C%A8Vue3%E4%B8%AD%E5%AE%9E%E7%8E%B0React-Hooks/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>最近在逛掘金的时候看到些比较有意思的文章可以在Vue3中调用React Hooks，所以就学习了一下发现了设计的巧妙之处，虽然我们可能永远用不到这个，但是学习一下实现的原理还是挺不错的。</li><li>首先本文不会过度深入讲解只属于 React 或者只属于 Vue 的内容，所以只懂 React 或者只懂 Vue 的同学都可以畅通无阻地阅读本文。  </li></ul><h2 id="在-Vue3-函数式组件中的-React-style-Hooks"><a href="#在-Vue3-函数式组件中的-React-style-Hooks" class="headerlink" title="在 Vue3 函数式组件中的 React-style Hooks"></a>在 Vue3 函数式组件中的 React-style Hooks</h2><p>我们先来看一段代码  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState, useReducer, useEffect, useLayoutEffect &#125; from &quot;vue-hooks-api&quot;;</span><br><span class="line"></span><br><span class="line">const FunctionalComponent &#x3D; (props, context) &#x3D;&gt; &#123;</span><br><span class="line">  const [count1, setCount1] &#x3D; useState(0);</span><br><span class="line">  const [count2, setCount2] &#x3D; useReducer((x) &#x3D;&gt; x + 1, 1);</span><br><span class="line">  const [count3, setCount3] &#x3D; useReducer((x) &#x3D;&gt; x + 1, 2);</span><br><span class="line"></span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;useEffect&quot;, count2);</span><br><span class="line">  &#125;, [count2]);</span><br><span class="line"></span><br><span class="line">  useLayoutEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;useLayoutEffect&quot;, count2);</span><br><span class="line">  &#125;, [count2]);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount1(2)&#125; &#123;...props&#125;&gt;</span><br><span class="line">        count1:&#123;count1&#125;</span><br><span class="line">      &lt;&#x2F;button&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount2()&#125; &#123;...props&#125;&gt;</span><br><span class="line">        count2:&#123;count2&#125;</span><br><span class="line">      &lt;&#x2F;button&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount3()&#125; &#123;...props&#125;&gt;</span><br><span class="line">        count3:&#123;count3&#125;</span><br><span class="line">      &lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default FunctionalComponent;</span><br></pre></td></tr></table></figure><p>React 的同学可能以为这是一个 React 的函数组件，其实不是，这是一个 Vue3 的函数式组件，通过 vue-hooks-api 包提供的 useState, useReducer, useEffect, useLayoutEffect 的 Hooks 函数，就可以在 Vue3 的函数式组件中使用了，再通过 JSX 方式使用则看起来基本可以跟 React Hooks 一样了。  </p><p>关于 vue-hooks-api npm 包<br>vue-hooks-api npm 包是本文作者发布的一个 React 风格的 Vue3 Hooks 包，目前只可使用于 Vue3 函数式组件，跟 React 的函数式组件的 Hooks 使用方式一致。<br>可以通过 yarn 方式安装体验。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add vue-hooks-api</span><br></pre></td></tr></table></figure><p>注意，此 npm 包目前只是一个实验性产品，旨在探讨如何在 Vue3 的函数组件中实现 React 式的函数组件 Hooks，请慎用于生产环境。 </p><p>下文也将围绕这个 vue-hooks-api npm 包是如何实现的进行讲解。  </p><h2 id="React-Hooks-的本质"><a href="#React-Hooks-的本质" class="headerlink" title="React Hooks 的本质"></a>React Hooks 的本质</h2><p>首先 React Hooks 只可以使用在 React 的函数组件上，在 React Hooks 出现之前 React 的函数组件是不可以存储属于自己的数据状态的，因故也不可以进行数据逻辑的复用。直到 React Hooks 的出现，在 React 的函数组件上就可以进行存储属于它自己的数据状态了，进而可以达到数据逻辑的复用。这也是 React Hooks 的作用，可以进行数据逻辑的复用。  </p><p>那么为什么 React 可以做到在函数组件上进行存储数据状态的呢？首先 React 函数组件的本质是一个函数，React 函数的更新就是重新执行 React 函数组件得到新的虚拟 DOM 数据。那么要在 React 函数组件上存储属于这个函数组件自己的数据，本质就是在一个函数上存储属于这个函数的数据，在这个函数的后续执行的时候还可以获取到它自己内部的变量数据，并且不会和其他函数组件的内部的变量数据发生冲突，这其中最好的实现方式就是实现一个闭包函数。  </p><p>React Hooks 的最简实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Hooks</span><br><span class="line">function useReducer(reducer, initalState) &#123;</span><br><span class="line">    let hook &#x3D; initalState</span><br><span class="line">    const dispatch &#x3D; (action) &#x3D;&gt; &#123;</span><br><span class="line">        hook &#x3D; reducer(hook, action)</span><br><span class="line">        &#x2F;&#x2F; 关键，执行 setCount 函数的时候会重新执行 FunctionComponent 函数</span><br><span class="line">        FunctionComponent()</span><br><span class="line">    &#125;</span><br><span class="line">    return [hook, dispatch]</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 函数组件</span><br><span class="line">function FunctionComponent() &#123;</span><br><span class="line">   const [count, setCount] &#x3D; useReducer(x &#x3D;&gt; x + 1, 0)</span><br><span class="line">    </span><br><span class="line">   return &#123;count, setCount&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const result &#x3D; FunctionComponent()</span><br><span class="line">&#x2F;&#x2F; 执行 setCount 会从新执行 FunctionComponent</span><br><span class="line">result.setCount()</span><br></pre></td></tr></table></figure><p>通过上面 React Hooks 的最简模型可以知道执行组件函数 FunctionComponent 可以看成从 Hooks 返回了两个变量 count 和 setCount，count 很明显是拿来展示使用的，setCount 则是拿来给用户交互使用的，当用户执行 setCount 的时候 FunctionComponent 会重新执行。其中关键的就是hi执行 setCount 函数的时候会重新执行 FunctionComponent 函数。  </p><p>上述 React Hooks 的最简模型还存在一个问题，当用户执行 setCount 的时候 FunctionComponent 重新执行的时候，hook 会被一直初始化，值不能进行迭代。那么我们知道 React 当中一个函数组件就是一个 Fiber 节点，所以可以把 hook 存储在 Fiber 节点上。因为 Fiber 节点变量相对于这个 Hook 函数来说，就是一个全局变量。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Fiber 节点</span><br><span class="line">const Fiber &#x3D; &#123;</span><br><span class="line">    type: FunctionComponent, &#x2F;&#x2F; Fiber 节点上的 type 属性是组件函数</span><br><span class="line">    memorizedState: null &#x2F;&#x2F; Fiber 节点上的 memorizedState 属性是 Hooks</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Hooks</span><br><span class="line">function useReducer(reducer, initalState) &#123;</span><br><span class="line">    &#x2F;&#x2F; 初始化的时候，如果 Fiber 节点的 Hooks 不存在则进行设置</span><br><span class="line">    if(!Fiber.memorizedState) Fiber.memorizedState &#x3D; initalState</span><br><span class="line">    const dispatch &#x3D; (action) &#x3D;&gt; &#123;</span><br><span class="line">        Fiber.memorizedState &#x3D; reducer(Fiber.memorizedState, action)</span><br><span class="line">        &#x2F;&#x2F; 关键，执行 setCount 函数的时候会重新执行 FunctionComponent 函数</span><br><span class="line">        Fiber.type()</span><br><span class="line">    &#125;</span><br><span class="line">    return [Fiber.memorizedState, dispatch]</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 函数组件</span><br><span class="line">function FunctionComponent() &#123;</span><br><span class="line">    const [count, setCount] &#x3D; useReducer(x &#x3D;&gt; x + 1, 0)</span><br><span class="line">    console.log(&quot;渲染的count:&quot;, count) </span><br><span class="line">    return &#123;count, setCount&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const result &#x3D; Fiber.type() &#x2F;&#x2F; 打印 0</span><br><span class="line">&#x2F;&#x2F; 执行 setCount 会从新执行 FunctionComponent</span><br><span class="line">result.setCount() &#x2F;&#x2F; 打印 1</span><br><span class="line">result.setCount() &#x2F;&#x2F; 打印 2</span><br><span class="line">result.setCount() &#x2F;&#x2F; 打印 3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>经过上述代码修改之后，一个最简单的 React Hooks 的模型就实现完成了，这也是 React Hooks 的本质。值得注意的是其中 reducer 的实现跟 Redux 的 reducer 的实现是很相似的，这是因为它们是同一个作者开发的功能的缘故。  </p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>实际上React Hooks的设计远比这个复杂多了，上述代码还存在两个比较大的问题，一个问题是当其他函数组件调用了这个hook的时候会使hook的状态改变，需要使用闭包来就行缓存，还有一个问题是在使用多个hooks的时候需要使用链表来存储这些hooks，由于我自己还没有完全理解这些原理所以就不分享了。</p><h2 id="如何在-Vue3-的函数组件中实现-React-式的函数组件-Hooks"><a href="#如何在-Vue3-的函数组件中实现-React-式的函数组件-Hooks" class="headerlink" title="如何在 Vue3 的函数组件中实现 React 式的函数组件 Hooks"></a>如何在 Vue3 的函数组件中实现 React 式的函数组件 Hooks</h2><p>不管我们写的是 SFC 组件还是 JSX 组件，最终会被编译成一个对象，这个对象上就有我们设置的 setup 方法，还有 render 方法，其中 SFC 组件的 render 是通过 template 模板编译出来的。然后再创建这个组件的虚拟DOM，再去渲染这个渲染 DOM，然后在渲染这个虚拟 DOM 的时候，如果是组件类型的虚拟 DOM 则需要创建组件实例，然后再执行组件实例上 render 方法获取组件的虚拟 DOM，然后再去渲染这个虚拟DOM，直到把所有的虚拟 DOM 渲染完毕，最后浏览器展示渲染的内容。  </p><p>React 是在每次执行函数组件方法之前，初始化 Hooks 的相关信息的，但我们是在 Vue3 框架之外去写的一个库，所以我们只能通过 Vue3 提供的 API 去实现我们的功能。首先我们可以通过 getCurrentInstance 这个 API 获取到当前函数组件的实例对象。我们是没办法在初始执行函数组件渲染之前对进行 Hooks 的初始化工作的，所以我们只能在获取 Hooks 的时候去进行 Hooks 的相关的初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function updateWorkInProgressHook() &#123;</span><br><span class="line">  const instance &#x3D; getCurrentInstance() as any;</span><br><span class="line">  if (</span><br><span class="line">    !currentlyRenderingFiber ||</span><br><span class="line">    currentlyRenderingFiber.uid !&#x3D;&#x3D; instance.uid</span><br><span class="line">  ) &#123;</span><br><span class="line">    renderHooks(instance);</span><br><span class="line">  &#125;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们想要在 Vue3 的函数组件上实现相同的功能，则是把 Hooks 的相关信息存储在对应的函数组件的实例对象上。另外在 Vue3 中如果需要将一个函数在组件渲染之后进行执行，则需要使用 watchEffect API，其中 options 的 flush 设置为 “post”，本质是渲染之后的 post 队列里面添加一个执行任务，从而达到跟 React 的 useEffect 的回调执行机制基本一致 。</p><p>实现的代码来自Cobyte</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line">import &#123; getCurrentInstance, watchEffect &#125; from &quot;vue&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; useLayoutEffect 的标记</span><br><span class="line">const HookLayout &#x3D; &#x2F;*    *&#x2F; 0b010;</span><br><span class="line">&#x2F;&#x2F; useEffect 的标记</span><br><span class="line">const HookPassive &#x3D; &#x2F;*   *&#x2F; 0b100;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 当前的渲染的 Fiber 节点，对应 Vue 中则是当前渲染的组件函数的实例</span><br><span class="line">let currentlyRenderingFiber: any &#x3D; null;</span><br><span class="line">&#x2F;&#x2F; 当前正在工作的 Hook 节点</span><br><span class="line">let workInProgressHook: any &#x3D; null;</span><br><span class="line">&#x2F;&#x2F; 前一个 Hook</span><br><span class="line">let currentHook: any &#x3D; null;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; React 中启动一个 Fiber 协调的任务</span><br><span class="line">function scheduleUpdateOnFiber(wip: any) &#123;</span><br><span class="line">  &#x2F;&#x2F; 保存老 Fiber</span><br><span class="line">  currentlyRenderingFiber.alternate &#x3D; &#123; ...currentlyRenderingFiber &#125;;</span><br><span class="line">  renderHooks(wip);</span><br><span class="line">  currentlyRenderingFiber.update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 初始化 Hooks 的相关设置</span><br><span class="line">function renderHooks(wip: any) &#123;</span><br><span class="line">  currentlyRenderingFiber &#x3D; wip;</span><br><span class="line">  currentlyRenderingFiber.memorizedState &#x3D; null;</span><br><span class="line">  workInProgressHook &#x3D; null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Hooks 设置</span><br><span class="line">function updateWorkInProgressHook() &#123;</span><br><span class="line">  const instance &#x3D; getCurrentInstance() as any;</span><br><span class="line">  if (</span><br><span class="line">    !currentlyRenderingFiber ||</span><br><span class="line">    currentlyRenderingFiber.uid !&#x3D;&#x3D; instance.uid</span><br><span class="line">  ) &#123;</span><br><span class="line">    renderHooks(instance);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; alternate 是老 Fiber 的属性 </span><br><span class="line">  const current &#x3D; currentlyRenderingFiber.alternate;</span><br><span class="line">  let hook;</span><br><span class="line">  &#x2F;&#x2F; 存在老的则是更新节点</span><br><span class="line">  if (current) &#123;</span><br><span class="line">    currentlyRenderingFiber.memorizedState &#x3D; current.memorizedState;</span><br><span class="line">    if (workInProgressHook) &#123;</span><br><span class="line">      &#x2F;&#x2F; 不是头节点</span><br><span class="line">      hook &#x3D; workInProgressHook &#x3D; workInProgressHook.next;</span><br><span class="line">      currentHook &#x3D; currentHook.next;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 头节点</span><br><span class="line">      hook &#x3D; workInProgressHook &#x3D; current.memorizedState;</span><br><span class="line">      currentHook &#x3D; current.memorizedState;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 初始化</span><br><span class="line">    currentHook &#x3D; null;</span><br><span class="line">    hook &#x3D; &#123;</span><br><span class="line">      memorizedState: null,</span><br><span class="line">      next: null,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    if (workInProgressHook) &#123;</span><br><span class="line">      &#x2F;&#x2F; 不是头节点</span><br><span class="line">      workInProgressHook &#x3D; workInProgressHook.next &#x3D; hook;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 头节点</span><br><span class="line">      workInProgressHook &#x3D; currentlyRenderingFiber.memorizedState &#x3D; hook;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return hook;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function useState(initalState: any) &#123;</span><br><span class="line">  return useReducer(null, initalState);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function useReducer(reducer: any, initalState: any) &#123;</span><br><span class="line">  &#x2F;&#x2F; 获取 Hook</span><br><span class="line">  const hook &#x3D; updateWorkInProgressHook();</span><br><span class="line"></span><br><span class="line">  if (!currentlyRenderingFiber.alternate) &#123;</span><br><span class="line">    hook.memorizedState &#x3D; initalState;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 通过 bind 方法进行缓存当前的组件函数的 Fiber 节点，Vue3 中则是函数组件的实例对象</span><br><span class="line">  const dispatch &#x3D; dispatchReducerAction.bind(</span><br><span class="line">    null,</span><br><span class="line">    currentlyRenderingFiber,</span><br><span class="line">    hook,</span><br><span class="line">    reducer</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  return [hook.memorizedState, dispatch];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function dispatchReducerAction(</span><br><span class="line">  fiber: any,</span><br><span class="line">  hook: any,</span><br><span class="line">  reducer: any,</span><br><span class="line">  action: any</span><br><span class="line">) &#123;</span><br><span class="line">  hook.memorizedState &#x3D; reducer ? reducer(hook.memorizedState) : action;</span><br><span class="line">  &#x2F;&#x2F; 调用 dispatch 的时候重新执行函数组件的渲染</span><br><span class="line">  scheduleUpdateOnFiber(fiber);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function updateEffectImp(hookFlags: any, create: any, deps: any) &#123;</span><br><span class="line">  &#x2F;&#x2F; 获取 Hook</span><br><span class="line">  const hook &#x3D; updateWorkInProgressHook();</span><br><span class="line">  &#x2F;&#x2F; 如果存在老 Hook 则进行对比</span><br><span class="line">  if (currentHook) &#123;</span><br><span class="line">    const prevEffect &#x3D; currentHook.memorizedState;</span><br><span class="line">    if (deps) &#123;</span><br><span class="line">      const prevDeps &#x3D; prevEffect.deps;</span><br><span class="line">      if (areHookInputsEqual(deps, prevDeps)) &#123;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  const effect &#x3D; &#123; hookFlags, create, deps &#125;;</span><br><span class="line">  hook.memorizedState &#x3D; effect;</span><br><span class="line"></span><br><span class="line">  invokeHooks(hookFlags, hook);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function useEffect(create: any, deps: any) &#123;</span><br><span class="line">  return updateEffectImp(HookPassive, create, deps);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function useLayoutEffect(create: any, deps: any) &#123;</span><br><span class="line">  return updateEffectImp(HookLayout, create, deps);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 比较前后两个依赖是否发生变化</span><br><span class="line">function areHookInputsEqual(nextDeps: any, prevDeps: any) &#123;</span><br><span class="line">  if (prevDeps &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for (let i &#x3D; 0; i &lt; prevDeps.length &amp;&amp; i &lt; nextDeps.length; i++) &#123;</span><br><span class="line">    if (Object.is(nextDeps[i], prevDeps[i])) &#123;</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 调用 Hooks</span><br><span class="line">function invokeHooks(hookFlags: any, hook: any) &#123;</span><br><span class="line">  if (hookFlags &amp; HookPassive) &#123;</span><br><span class="line">    postMessage(hook.memorizedState.create);</span><br><span class="line">  &#125; else if (hookFlags &amp; HookLayout) &#123;</span><br><span class="line">    watchEffect(hook.memorizedState.create, &#123; flush: &quot;post&quot; &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过 MessageChannel 创建一个宏任务</span><br><span class="line">const postMessage &#x3D; (create: any) &#x3D;&gt; &#123;</span><br><span class="line">  const &#123; port1, port2 &#125; &#x3D; new MessageChannel();</span><br><span class="line">  port1.onmessage &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    create();</span><br><span class="line">  &#125;;</span><br><span class="line">  port2.postMessage(null);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> Hooks </tag>
            
            <tag> Vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js逆向之模拟浏览器环境</title>
      <link href="/2022/08/05/js%E9%80%86%E5%90%91%E4%B9%8B%E6%A8%A1%E6%8B%9F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%8E%AF%E5%A2%83/"/>
      <url>/2022/08/05/js%E9%80%86%E5%90%91%E4%B9%8B%E6%A8%A1%E6%8B%9F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间在js逆向学习过程中，除了一些简单网站的逆向没有使用或检测dom和bom，一般的网站都需要补全浏览器环境，为了更方便进行学习，我找了一些网上的教程结合自己实现了一个简单的浏览器环境框架。今天我就来讲一下开发的思路和具体怎么使用。</p><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>这个框架叫做catvm，参考了志远大佬的思路实现，完整的代码已经在github上开源，如果感兴趣可以访问我的github或者点击下面链接查看<a href="https://github.com/fanchangrui/catvm">https://github.com/fanchangrui/catvm</a><br>此项目已经被开源安全社区OSCS收录并检测安全，请大家放心食用。<br><a href="https://www.oscs1024.com/project/fanchangrui/catvm?ref=badge_small"><img src="https://www.oscs1024.com/platform/badge/fanchangrui/catvm.svg?size=small" alt="OSCS Status"></a></p><p><a href="https://www.oscs1024.com/project/fanchangrui/catvm?ref=badge_large"><img src="https://www.oscs1024.com/platform/badge/fanchangrui/catvm.svg?size=large" alt="OSCS Status"></a></p><h2 id="2-使用方法"><a href="#2-使用方法" class="headerlink" title="2 使用方法"></a>2 使用方法</h2><p>首先我们先讲一下使用方法，如何实现和二次开发在第三节中讲到</p><ul><li>把扣下来的代码放到code.js中</li><li>调试运行index.js</li><li>如果报错看错误补充检测的环境  <h3 id="没错就是这么简单，如果你逆的网站监测不是那么严格的话，直接调试就可以出结果了，如果还检查了其他地方就要自己补全剩下的环境。"><a href="#没错就是这么简单，如果你逆的网站监测不是那么严格的话，直接调试就可以出结果了，如果还检查了其他地方就要自己补全剩下的环境。" class="headerlink" title="没错就是这么简单，如果你逆的网站监测不是那么严格的话，直接调试就可以出结果了，如果还检查了其他地方就要自己补全剩下的环境。"></a>没错就是这么简单，如果你逆的网站监测不是那么严格的话，直接调试就可以出结果了，如果还检查了其他地方就要自己补全剩下的环境。</h3></li></ul><h2 id="3-开发思路"><a href="#3-开发思路" class="headerlink" title="3 开发思路"></a>3 开发思路</h2><p>这节我简单讲一下开发的思路和怎么进行补充环境来打造属于你自己的模拟环境，随着你逆向的网站越来越多，补充的环境也会越来越完善，相信你经过一段时间可以应对80%的环境检测。  </p><h3 id="3-1-目录结构"><a href="#3-1-目录结构" class="headerlink" title="3.1 目录结构"></a>3.1 目录结构</h3><p>src文件夹下分为catvm2、tools、code.js、index.js四个文件夹，其中catvm2是catvm的源码，tools是一些工具，code.js是你扣下来的代码，index.js是你的调试入口。tools只是一段方便自动获取浏览器环境的脚本，自己手补的可以不用管这个。<br>核心的catvm2分为browser和tools，browser是具体的各个检测对象的实现代码，tools设计了一些框架缓存，封装的一些工具方法比如保护函数、代理、打印错误等。<br><img src="/img/805/1.png" alt="这是图片" title="Magic Gardens"></p><h3 id="3-2-核心思想"><a href="#3-2-核心思想" class="headerlink" title="3.2 核心思想"></a>3.2 核心思想</h3><p>因为node和浏览器环境等相似性，我们借用node环境等基础来实现，但是现在大多数网站都检测了node，所以我们引入vm2这个包来实现纯净的v8环境。<br>dom和bom实际上就是在全局挂载了几个对象，我们以前在补充这些时可能直接声明了一个普通对象在加点属性就可以绕过检测，但是实际上这是不严谨的，有些网站会检测在原型上有没有，这也是js这个语言的原理。<br>现在我们来简单实现如何在原型上添加对象：<br>已document这个对象为例，不熟悉js原型的建议先去学习一下再看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const Document &#x3D;function Document()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Object.defineProperties(Document.prototype,&#123;</span><br><span class="line">    [Symbol.toStringTag]:&#123;</span><br><span class="line">        value:&#39;Document&#39;,</span><br><span class="line">        configurable:true,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">document &#x3D; &#123;&#125;</span><br><span class="line">document.__proto__ &#x3D; Document.prototype</span><br></pre></td></tr></table></figure><p>这样就实现了最简单的document对象，然后可以在这个对象下面加一下用到了属性和方法比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">document.cookie &#x3D; &#39;&#39;</span><br><span class="line">document.referrer &#x3D; location.href || &#39;&#39;</span><br><span class="line">document.getElementById &#x3D; function getElementById(id)&#123;</span><br><span class="line">    return null</span><br><span class="line">&#125;</span><br><span class="line">document.addEventListener &#x3D; function addEventListener(type,listener,useCapture)&#123;   </span><br><span class="line">&#125;</span><br><span class="line">document.createElement &#x3D; function createElement(tagName)&#123;</span><br><span class="line">        let tagname &#x3D; tagName.toLowerCase() + &#39;&#39;</span><br><span class="line">        if(catvm.memory.htmlElements[tagname] &#x3D;&#x3D; undefined)&#123;</span><br><span class="line">            debugger</span><br><span class="line">        &#125;</span><br><span class="line">        return catvm.proxy(catvm.memory.htmlElements[tagname]())</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是实际上v8对这个对象做了很多限制，我们可以封装保护函数、代理等方法来加强,这个具体再tools讲。如果一个对象在浏览器中无法看具体方法，我们要在定义的时候抛出getter错误。具体每个对象的实现参考js官方文档mdn <a href="https://developer.mozilla.org/zh-CN/">https://developer.mozilla.org/zh-CN/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw new TypeError(&#39;Illegal constructor&#39;)</span><br></pre></td></tr></table></figure><h3 id="3-3-tools工具实现"><a href="#3-3-tools工具实现" class="headerlink" title="3.3 tools工具实现"></a>3.3 tools工具实现</h3><ul><li>memory.js: 内存缓存，用来缓存一我们自己注入的一些对象，不污染全局环境，即使日后被检测了改一下名字也能逃过检测。<br><img src="/img/805/2.png" alt="这是图片" title="Magic Gardens">  </li><li>proxy.js:代理函数，给我们自己模拟的对象加上后就可以查看到这个对象下哪个属性或方法被检测到了，方便我们补环境。<br><img src="/img/805/3.png" alt="这是图片" title="Magic Gardens">  </li><li>safefunction.js:保护函数，因为js每个对象的原型上都有toString方法，所以我们自己重写一个toString方法的来规避检测。尽量每一个函数都用safefunction保护一下。<br><img src="/img/805/4.png" alt="这是图片" title="Magic Gardens">  </li><li>node.js:整合工具文件，把上面几个文件合并成一个文件，方便我们使用。</li></ul><h3 id="3-4-注意点"><a href="#3-4-注意点" class="headerlink" title="3.4 注意点"></a>3.4 注意点</h3><ul><li>catcm.node.js和tools下的node.js都是整合的功能，每加入一个浏览器属性对象或者工具都要放入.node.js结尾的文件中，当然你也可以写个遍历函数循环读取加入。</li><li>本框架用的是es6模块语法，如果要使用node老版本的commonjs语法的请在pack.json中删除 “type”，这样自动使用commonjs语法进行编译。</li></ul><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本框架只补充了浏览器的几个基础对象和开放接口，很有可能无法直接使用，建议有一定基础的开发者研究并不断完善，最后说一句：逆向虽好，但切记不要利用这个去做违法的事。</p>]]></content>
      
      
      <categories>
          
          <category> js逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js逆向 </tag>
            
            <tag> 浏览器环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js逆向之某度翻译</title>
      <link href="/2022/07/22/js%E9%80%86%E5%90%91%E4%B9%8B%E6%9F%90%E5%BA%A6%E7%BF%BB%E8%AF%91/"/>
      <url>/2022/07/22/js%E9%80%86%E5%90%91%E4%B9%8B%E6%9F%90%E5%BA%A6%E7%BF%BB%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>快速优雅地学会JS逆向，就需要从实战开始，接下来我会提供Base64加密的原网址以及接口参数，从实战中学习如何下断点、抠代码、本地运行等操作，此技术一般用于爬虫上，是一个爬虫程序猿进阶的必经之路。</p><h2 id="实战信息"><a href="#实战信息" class="headerlink" title="实战信息"></a>实战信息</h2><p>网址：<a href="https://fanyi.baidu.com/">https://fanyi.baidu.com/</a><br>接口：<a href="https://fanyi.baidu.com/v2transapi">https://fanyi.baidu.com/v2transapi</a><br>逆向参数：</p><ul><li>sign:232427.485594  </li><li>token:3dde9ef10b6f6ae310af38e6f1bd564f  </li></ul><h2 id="实战流程"><a href="#实战流程" class="headerlink" title="实战流程"></a>实战流程</h2><h3 id="1-抓包分析"><a href="#1-抓包分析" class="headerlink" title="1.抓包分析"></a>1.抓包分析</h3><p>首先，进入页面按F12，打开控制面板，调到Network板块后在翻译处写入需要翻译的信息(我这里输入的是“你好”)触发网络请求，打开请求面板查看该请求的具体信息。<br><img src="/img/722/1.png" alt="这是图片" title="Magic Gardens"><br>General：请求信息  </p><ul><li>URL：请求API地址</li><li>Method：请求方式GET/POST<br>Request headers：请求头<br>除了自定义请求头参数，其余Host、Origin、Referer一般为爬虫必须参数，Cookie看站点是否有对其校验，如果有特殊的自定义参数一般也为爬虫需要。   </li><li>Acs-Token：自定义的校验参数</li><li>Cookie：客户端缓存信息</li><li>Host：域名</li><li>Origin：来源信息</li><li>Referer：防止跨站攻击  </li></ul><h3 id="2-查找加密参数"><a href="#2-查找加密参数" class="headerlink" title="2.查找加密参数"></a>2.查找加密参数</h3><p><img src="/img/722/2.png" alt="这是图片" title="Magic Gardens"><br> 从上图中可以看到sign和token有加密嫌疑，所以目标就暂定为对这两个参数进行一个简单逆向。  </p><h3 id="3-断点分类"><a href="#3-断点分类" class="headerlink" title="3.断点分类"></a>3.断点分类</h3><p> 下断多种方法：<br> 1.元素下断<br> 2.事件下断<br> 3.XHR下断<br> 4.搜索下断  </p><h3 id="4-学会快速下断"><a href="#4-学会快速下断" class="headerlink" title="4.学会快速下断"></a>4.学会快速下断</h3><p> 这里主要展示XHR下断和搜索下断，在此比较好用<br>XHR断点：首先复制请求链接?前的部分路径，这里是/v2transapi,到Source下的XHR断点处下断，回车输入新翻译内容即可触发。<br><img src="/img/722/3.png" alt="这是图片" title="Magic Gardens"><br><img src="/img/722/4.png" alt="这是图片" title="Magic Gardens"><br>可以看到断点断在了send()方法的调用处，在Call stack中查看函数方法的调用栈，目前代码可读性太低，我们需要对其进行格式化查看，就需要左下角的{}按钮。<br>在调用栈中查看自己所需参数的作用域，首先在调用栈中找到加密后的参数位置，然后往前推，直到找到加密的方法，此处直接展示寻找结果。<br><img src="/img/722/5.png" alt="这是图片" title="Magic Gardens"><br>如上图，作用域的位置就看提示的参数数据即可，windows下如果使用Chrome可以用ctrl键触发，这里查看的是ajax()的方法栈，同时我们可以找到加密后的结果，鼠标放到函数参数里可以看到，我们也可以直接从Scope中查看然后返回源码找。<br><img src="/img/722/6.png" alt="这是图片" title="Magic Gardens"><br>此处左右两侧都可以看到一个加密后的sign和token数据,就往前找调用的方法栈即可。<br><img src="/img/722/7.png" alt="这是图片" title="Magic Gardens"><br>再往前一个方法栈就可以看到，headers里面必须有个”Acs-Token”的参数，data中的数据来源是b，往上看b是一个对象，请求内容在对象里，sign:x(n)｜token:window.common.token这两个参数是这样获取的。<br>我们可以直接知道x(n)就是sign的加密函数,token存在window.common下。<br><img src="/img/722/8.png" alt="这是图片" title="Magic Gardens"><br> 鼠标放置在x函数上会给一个跳转提示，点击index_61616b2.js有利于我们直接找到函数调用的方法，我们可以直接去抠代码本地运行,n鼠标放上去可以发现就是”你好”,将断点打在8782行，重新键入更改断点作用域。<br><img src="/img/722/9.png" alt="这是图片" title="Magic Gardens"><br>测试确认x(n)方法确实是sign获取的方法位置，进入函数。<br><img src="/img/722/10.png" alt="这是图片" title="Magic Gardens"><br>此处可以直接抠到本地用Node运行，代码调用可以看到调用了两个作用域里的函数，所以对代码抠全，进行部分改写，此处直接粘代码。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">function a(r) &#123;</span><br><span class="line">    if (Array.isArray(r)) &#123;</span><br><span class="line">        for (var o &#x3D; 0, t &#x3D; Array(r.length); o &lt; r.length; o++)</span><br><span class="line">            t[o] &#x3D; r[o];</span><br><span class="line">        return t</span><br><span class="line">    &#125;</span><br><span class="line">    return Array.from(r)</span><br><span class="line">&#125;</span><br><span class="line">function n(r, o) &#123;</span><br><span class="line">    for (var t &#x3D; 0; t &lt; o.length - 2; t +&#x3D; 3) &#123;</span><br><span class="line">        var a &#x3D; o.charAt(t + 2);</span><br><span class="line">        a &#x3D; a &gt;&#x3D; &quot;a&quot; ? a.charCodeAt(0) - 87 : Number(a),</span><br><span class="line">        a &#x3D; &quot;+&quot; &#x3D;&#x3D;&#x3D; o.charAt(t + 1) ? r &gt;&gt;&gt; a : r &lt;&lt; a,</span><br><span class="line">        r &#x3D; &quot;+&quot; &#x3D;&#x3D;&#x3D; o.charAt(t) ? r + a &amp; 4294967295 : r ^ a</span><br><span class="line">    &#125;</span><br><span class="line">    return r</span><br><span class="line">&#125;</span><br><span class="line">function e(r) &#123;</span><br><span class="line">    var o &#x3D; r.match(&#x2F;[\uD800-\uDBFF][\uDC00-\uDFFF]&#x2F;g);</span><br><span class="line">    if (null &#x3D;&#x3D;&#x3D; o) &#123;</span><br><span class="line">        var t &#x3D; r.length;</span><br><span class="line">        t &gt; 30 &amp;&amp; (r &#x3D; &quot;&quot; + r.substr(0, 10) + r.substr(Math.floor(t &#x2F; 2) - 5, 10) + r.substr(-10, 10))</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (var e &#x3D; r.split(&#x2F;[\uD800-\uDBFF][\uDC00-\uDFFF]&#x2F;), C &#x3D; 0, h &#x3D; e.length, f &#x3D; []; h &gt; C; C++)</span><br><span class="line">            &quot;&quot; !&#x3D;&#x3D; e[C] &amp;&amp; f.push.apply(f, a(e[C].split(&quot;&quot;))),</span><br><span class="line">            C !&#x3D;&#x3D; h - 1 &amp;&amp; f.push(o[C]);</span><br><span class="line">        var g &#x3D; f.length;</span><br><span class="line">        g &gt; 30 &amp;&amp; (r &#x3D; f.slice(0, 10).join(&quot;&quot;) + f.slice(Math.floor(g &#x2F; 2) - 5, Math.floor(g &#x2F; 2) + 5).join(&quot;&quot;) + f.slice(-10).join(&quot;&quot;))</span><br><span class="line">    &#125;</span><br><span class="line">    var u &#x3D; void 0</span><br><span class="line">      , l &#x3D; &quot;&quot; + String.fromCharCode(103) + String.fromCharCode(116) + String.fromCharCode(107);</span><br><span class="line">    u &#x3D; null !&#x3D;&#x3D; i ? i : (i &#x3D; window[l] || &quot;&quot;) || &quot;&quot;;</span><br><span class="line">    for (var d &#x3D; u.split(&quot;.&quot;), m &#x3D; Number(d[0]) || 0, s &#x3D; Number(d[1]) || 0, S &#x3D; [], c &#x3D; 0, v &#x3D; 0; v &lt; r.length; v++) &#123;</span><br><span class="line">        var A &#x3D; r.charCodeAt(v);</span><br><span class="line">        128 &gt; A ? S[c++] &#x3D; A : (2048 &gt; A ? S[c++] &#x3D; A &gt;&gt; 6 | 192 : (55296 &#x3D;&#x3D;&#x3D; (64512 &amp; A) &amp;&amp; v + 1 &lt; r.length &amp;&amp; 56320 &#x3D;&#x3D;&#x3D; (64512 &amp; r.charCodeAt(v + 1)) ? (A &#x3D; 65536 + ((1023 &amp; A) &lt;&lt; 10) + (1023 &amp; r.charCodeAt(++v)),</span><br><span class="line">        S[c++] &#x3D; A &gt;&gt; 18 | 240,</span><br><span class="line">        S[c++] &#x3D; A &gt;&gt; 12 &amp; 63 | 128) : S[c++] &#x3D; A &gt;&gt; 12 | 224,</span><br><span class="line">        S[c++] &#x3D; A &gt;&gt; 6 &amp; 63 | 128),</span><br><span class="line">        S[c++] &#x3D; 63 &amp; A | 128)</span><br><span class="line">    &#125;</span><br><span class="line">    for (var p &#x3D; m, F &#x3D; &quot;&quot; + String.fromCharCode(43) + String.fromCharCode(45) + String.fromCharCode(97) + (&quot;&quot; + String.fromCharCode(94) + String.fromCharCode(43) + String.fromCharCode(54)), D &#x3D; &quot;&quot; + String.fromCharCode(43) + String.fromCharCode(45) + String.fromCharCode(51) + (&quot;&quot; + String.fromCharCode(94) + String.fromCharCode(43) + String.fromCharCode(98)) + (&quot;&quot; + String.fromCharCode(43) + String.fromCharCode(45) + String.fromCharCode(102)), b &#x3D; 0; b &lt; S.length; b++)</span><br><span class="line">        p +&#x3D; S[b],</span><br><span class="line">        p &#x3D; n(p, F);</span><br><span class="line">    return p &#x3D; n(p, D),</span><br><span class="line">    p ^&#x3D; s,</span><br><span class="line">    0 &gt; p &amp;&amp; (p &#x3D; (2147483647 &amp; p) + 2147483648),</span><br><span class="line">    p %&#x3D; 1e6,</span><br><span class="line">    p.toString() + &quot;.&quot; + (p ^ m)</span><br><span class="line">&#125;</span><br><span class="line">console.log(e(&#39;你好&#39;))</span><br></pre></td></tr></table></figure><p>调试发现报错(命令行输入node xx.js)：<br><img src="/img/722/11.png" alt="这是图片" title="Magic Gardens"><br>因为本地环境没有window对象，因为l是一步计算的到为固定值，我们需要获取到window[l]的值，就先获取l的值，鼠标放在l上即可获取因为此算法为固定值，获取到l = “gtk”，所以此处的window[l] === window[“gtk”],我们通过搜索ctrl+shift+f/Command+shift+f调出搜索面板，通过搜索(window[“gtk”]｜window[‘gtk’]｜window.gtk)这三个方法去查找，就看此处调用哪个，某度翻译用的window.gtk，是一个固定值。<br><img src="/img/722/12.png" alt="这是图片" title="Magic Gardens"><br>直接抠值替换源码里的window[l]即可，调试发现i还是undefined,所以在变量上定义一个i的初始化方法即可。<br><img src="/img/722/13.png" alt="这是图片" title="Magic Gardens"><br>再次测试调用，对比浏览器请求参数。<br><img src="/img/722/14.png" alt="这是图片" title="Magic Gardens"><br>结果一致就说明获取成功了，获取到sign了还有个token值没有获取，这个又怎么获取呢。上面我们发现是window.common.token产生，通过搜索(window[“common”]｜window[‘common’]｜window.common)先找父节点值，这里用window[‘common’]即可搜到，发现common是页面定义的变量，刷新页面发现token值写死我们这里就直接获取到了token值。<br><img src="/img/722/15.png" alt="这是图片" title="Magic Gardens">   </p><h2 id="js完整代码"><a href="#js完整代码" class="headerlink" title="js完整代码"></a>js完整代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">var token &#x3D; &quot;3dde9ef10b6f6ae310af38e6f1bd564f&quot;</span><br><span class="line"></span><br><span class="line">function a(r) &#123;</span><br><span class="line">    if (Array.isArray(r)) &#123;</span><br><span class="line">        for (var o &#x3D; 0, t &#x3D; Array(r.length); o &lt; r.length; o++)</span><br><span class="line">            t[o] &#x3D; r[o];</span><br><span class="line">        return t</span><br><span class="line">    &#125;</span><br><span class="line">    return Array.from(r)</span><br><span class="line">&#125;</span><br><span class="line">function n(r, o) &#123;</span><br><span class="line">    for (var t &#x3D; 0; t &lt; o.length - 2; t +&#x3D; 3) &#123;</span><br><span class="line">        var a &#x3D; o.charAt(t + 2);</span><br><span class="line">        a &#x3D; a &gt;&#x3D; &quot;a&quot; ? a.charCodeAt(0) - 87 : Number(a),</span><br><span class="line">        a &#x3D; &quot;+&quot; &#x3D;&#x3D;&#x3D; o.charAt(t + 1) ? r &gt;&gt;&gt; a : r &lt;&lt; a,</span><br><span class="line">        r &#x3D; &quot;+&quot; &#x3D;&#x3D;&#x3D; o.charAt(t) ? r + a &amp; 4294967295 : r ^ a</span><br><span class="line">    &#125;</span><br><span class="line">    return r</span><br><span class="line">&#125;</span><br><span class="line">function e(r) &#123;</span><br><span class="line">    var o &#x3D; r.match(&#x2F;[\uD800-\uDBFF][\uDC00-\uDFFF]&#x2F;g);</span><br><span class="line">    if (null &#x3D;&#x3D;&#x3D; o) &#123;</span><br><span class="line">        var t &#x3D; r.length;</span><br><span class="line">        t &gt; 30 &amp;&amp; (r &#x3D; &quot;&quot; + r.substr(0, 10) + r.substr(Math.floor(t &#x2F; 2) - 5, 10) + r.substr(-10, 10))</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (var e &#x3D; r.split(&#x2F;[\uD800-\uDBFF][\uDC00-\uDFFF]&#x2F;), C &#x3D; 0, h &#x3D; e.length, f &#x3D; []; h &gt; C; C++)</span><br><span class="line">            &quot;&quot; !&#x3D;&#x3D; e[C] &amp;&amp; f.push.apply(f, a(e[C].split(&quot;&quot;))),</span><br><span class="line">            C !&#x3D;&#x3D; h - 1 &amp;&amp; f.push(o[C]);</span><br><span class="line">        var g &#x3D; f.length;</span><br><span class="line">        g &gt; 30 &amp;&amp; (r &#x3D; f.slice(0, 10).join(&quot;&quot;) + f.slice(Math.floor(g &#x2F; 2) - 5, Math.floor(g &#x2F; 2) + 5).join(&quot;&quot;) + f.slice(-10).join(&quot;&quot;))</span><br><span class="line">    &#125;</span><br><span class="line">    var u &#x3D; void 0</span><br><span class="line">    , l &#x3D; &quot;&quot; + String.fromCharCode(103) + String.fromCharCode(116) + String.fromCharCode(107);</span><br><span class="line">    var i &#x3D; null;</span><br><span class="line">    u &#x3D; null !&#x3D;&#x3D; i ? i : (i &#x3D; &quot;320305.131321201&quot; || &quot;&quot;) || &quot;&quot;;</span><br><span class="line">    for (var d &#x3D; u.split(&quot;.&quot;), m &#x3D; Number(d[0]) || 0, s &#x3D; Number(d[1]) || 0, S &#x3D; [], c &#x3D; 0, v &#x3D; 0; v &lt; r.length; v++) &#123;</span><br><span class="line">        var A &#x3D; r.charCodeAt(v);</span><br><span class="line">        128 &gt; A ? S[c++] &#x3D; A : (2048 &gt; A ? S[c++] &#x3D; A &gt;&gt; 6 | 192 : (55296 &#x3D;&#x3D;&#x3D; (64512 &amp; A) &amp;&amp; v + 1 &lt; r.length &amp;&amp; 56320 &#x3D;&#x3D;&#x3D; (64512 &amp; r.charCodeAt(v + 1)) ? (A &#x3D; 65536 + ((1023 &amp; A) &lt;&lt; 10) + (1023 &amp; r.charCodeAt(++v)),</span><br><span class="line">        S[c++] &#x3D; A &gt;&gt; 18 | 240,</span><br><span class="line">        S[c++] &#x3D; A &gt;&gt; 12 &amp; 63 | 128) : S[c++] &#x3D; A &gt;&gt; 12 | 224,</span><br><span class="line">        S[c++] &#x3D; A &gt;&gt; 6 &amp; 63 | 128),</span><br><span class="line">        S[c++] &#x3D; 63 &amp; A | 128)</span><br><span class="line">    &#125;</span><br><span class="line">    for (var p &#x3D; m, F &#x3D; &quot;&quot; + String.fromCharCode(43) + String.fromCharCode(45) + String.fromCharCode(97) + (&quot;&quot; + String.fromCharCode(94) + String.fromCharCode(43) + String.fromCharCode(54)), D &#x3D; &quot;&quot; + String.fromCharCode(43) + String.fromCharCode(45) + String.fromCharCode(51) + (&quot;&quot; + String.fromCharCode(94) + String.fromCharCode(43) + String.fromCharCode(98)) + (&quot;&quot; + String.fromCharCode(43) + String.fromCharCode(45) + String.fromCharCode(102)), b &#x3D; 0; b &lt; S.length; b++)</span><br><span class="line">        p +&#x3D; S[b],</span><br><span class="line">        p &#x3D; n(p, F);</span><br><span class="line">    return p &#x3D; n(p, D),</span><br><span class="line">    p ^&#x3D; s,</span><br><span class="line">    0 &gt; p &amp;&amp; (p &#x3D; (2147483647 &amp; p) + 2147483648),</span><br><span class="line">    p %&#x3D; 1e6,</span><br><span class="line">    p.toString() + &quot;.&quot; + (p ^ m)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; console.log(e(&#39;你好&#39;))</span><br><span class="line">&#x2F;&#x2F; console.log(token)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取Sign</span><br><span class="line">function getSign(str)&#123;</span><br><span class="line">    return e(str)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 获取Token</span><br><span class="line">function getToken()&#123;</span><br><span class="line">    return token</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Node导出方法方式</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    getSign,</span><br><span class="line">    getToken</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 此文章仅做学习之用，请勿做违法违纪之事。</p>]]></content>
      
      
      <categories>
          
          <category> js逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js逆向 </tag>
            
            <tag> 反爬 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js逆向</title>
      <link href="/2022/07/15/js%E9%80%86%E5%90%91/"/>
      <url>/2022/07/15/js%E9%80%86%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h2 id="为啥接触到js逆向？"><a href="#为啥接触到js逆向？" class="headerlink" title="为啥接触到js逆向？"></a>为啥接触到js逆向？</h2><p>在学习python爬虫框架爬取网站数据的时候发现大多数网站都不能直接爬取，在前端js文件中做了许多反爬限制，需要对js进行逆向解析，而我正好是一名前端开发工程师，所以在稍微学习了一下后基本了解了一些技巧。</p><h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><h3 id="1逆向环境"><a href="#1逆向环境" class="headerlink" title="1逆向环境"></a>1逆向环境</h3><ul><li>Node.js14.0以上版本<br>_官网下载地址：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a><br>_教程：<a href="https://www.runoob.com/nodejs/nodejs-install-setup.html">https://www.runoob.com/nodejs/nodejs-install-setup.html</a></li><li>Chrome浏览器 / Firefox浏览器<br>_Chrome官网：<a href="https://www.google.cn/intl/zh-CN/chrome/">https://www.google.cn/intl/zh-CN/chrome/</a><br>_Firefox官网：<a href="http://www.firefox.com.cn/">http://www.firefox.com.cn/</a>  </li><li>VScode<br>_官网下载地址：<a href="https://code.visualstudio.com/">https://code.visualstudio.com</a></li></ul><h3 id="谷歌浏览器调试"><a href="#谷歌浏览器调试" class="headerlink" title="谷歌浏览器调试"></a>谷歌浏览器调试</h3><ul><li>1 右键页面 -&gt; 检查 ｜ 按F12触发<br><img src="/img/715/1.png" alt="这是图片"></li><li>2 Element面板  </li></ul><p>*下元素断点：选择Break on-&gt;subtree modification<br><img src="/img/715/2.png" alt="这是图片"></p><ul><li>3 Console面板<br>勾选如下设置，此面板主要用于查看开发日志以及与JS交互。<br><img src="/img/715/3.png" alt="这是图片"></li><li>4 Sources面板<br>此处有3个模块在逆向过程常用，在以后教程会单独举例讲。<br>Page板块<br><img src="/img/715/4.png" alt="这是图片"><br>页面加载所加载的资源都在这里，具体内容可以点开后下断点。<br>Overrides板块<br><img src="/img/715/5.png" alt="这是图片"><br>此板块用于项目重写，在Page页选择跳到Overrides的话就可以直接本地替换掉原有的文件。<br>Snippets板块<br><img src="/img/715/6.png" alt="这是图片">   </li><li>5 Network板块<br><img src="/img/715/7.png" alt="这是图片"><br>可以看到网页加载时的请求链接，可以看到加密的参数这些情况,具体在后面会说到。</li></ul>]]></content>
      
      
      <categories>
          
          <category> js逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js逆向 </tag>
            
            <tag> 反爬 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scrapy框架爬取数据</title>
      <link href="/2022/06/21/scrapy%E6%A1%86%E6%9E%B6%E7%88%AC%E5%8F%96%E6%95%B0%E6%8D%AE/"/>
      <url>/2022/06/21/scrapy%E6%A1%86%E6%9E%B6%E7%88%AC%E5%8F%96%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="scrapy框架介绍"><a href="#scrapy框架介绍" class="headerlink" title="scrapy框架介绍"></a>scrapy框架介绍</h2><ul><li>Scrapy是适用于Python的一个快速、高层次的屏幕抓取和web抓取框架，用于抓取web站点并从页面中提取结构化的数据。Scrapy用途广泛，可以用于数据挖掘、监测和自动化测试。  </li><li>Scrapy吸引人的地方在于它是一个框架，任何人都可以根据需求方便的修改。它也提供了多种类型爬虫的基类，如BaseSpider、sitemap爬虫等，最新版本又提供了web2.0爬虫的支持。  </li></ul><h3 id="为什么使用scrapy？"><a href="#为什么使用scrapy？" class="headerlink" title="为什么使用scrapy？"></a>为什么使用scrapy？</h3><p>scrapy框架，将网页采集的通用功能，集成到各个模块中，留出自己定义的部分，它将程序员从繁冗的流程式重复劳动中解放出来，简单的网页爬虫的重点，就集中在应对反爬，大规模爬取和高效稳定的爬取这几个方面。  </p><ul><li>scrapy 是异步的，可以灵活调节并发量</li><li>采取可读性更强的 xpath 代替正则，速度快</li><li>写 middleware,方便写一些统一的过滤器</li><li>同时在不同的 url 上爬行</li><li>支持 shell 方式，方便独立调试</li><li>通过管道的方式存入数据库，灵活，可保存为多种形式</li></ul><h2 id="scrapy初步体验"><a href="#scrapy初步体验" class="headerlink" title="scrapy初步体验"></a>scrapy初步体验</h2><h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><p>使用pip包管理工具安装scrapy，如果没有安装pip首先安装pip，因为我使用的是mac所以执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install pip</span><br></pre></td></tr></table></figure><h3 id="下载scrapy"><a href="#下载scrapy" class="headerlink" title="下载scrapy"></a>下载scrapy</h3><p>因为m1pro自带python3所以使用pip3命令，如果环境是python2使用pip</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install scrapy</span><br></pre></td></tr></table></figure><h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><p>在开始爬取之前，必须创建一个新的Scrapy项目。进入自定义的项目目录中，运行下列命令：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy startproject mySpider</span><br></pre></td></tr></table></figure><h3 id="明确爬取的目标"><a href="#明确爬取的目标" class="headerlink" title="明确爬取的目标"></a>明确爬取的目标</h3><p>我打算爬取豆瓣网的数据就在spider目录下创建douban.py的文件。</p><h3 id="爬取数据"><a href="#爬取数据" class="headerlink" title="爬取数据"></a>爬取数据</h3><p>编写douban.py获取每个电影的标题、评分和主题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import scrapy</span><br><span class="line">from scrapy import Selector,Request</span><br><span class="line">from scrapy.http import HtmlResponse</span><br><span class="line"></span><br><span class="line">from py3.items import MovieItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class DoubanSpider(scrapy.Spider):</span><br><span class="line">    name &#x3D; &#39;douban&#39;</span><br><span class="line">    allowed_domains &#x3D; [&#39;movie.douban.com&#39;]</span><br><span class="line">    start_urls &#x3D; [&#39;https:&#x2F;&#x2F;movie.douban.com&#x2F;top250&#39;]</span><br><span class="line"></span><br><span class="line">    def parse(self, response: HtmlResponse):</span><br><span class="line">        sel &#x3D; Selector(response)</span><br><span class="line">        list_items &#x3D; sel.css(&#39;#content &gt; div &gt; div.article &gt; ol &gt; li&#39;)</span><br><span class="line">        for list_item in list_items:</span><br><span class="line">            movie_item &#x3D; MovieItem()</span><br><span class="line">            movie_item[&#39;title&#39;] &#x3D; list_item.css(&#39;span.title::text&#39;).extract_first()</span><br><span class="line">            movie_item[&#39;rank&#39;] &#x3D; list_item.css(&#39;span.rating_num::text&#39;).extract_first()</span><br><span class="line">            movie_item[&#39;subject&#39;] &#x3D; list_item.css(&#39;span.inq::text&#39;).extract_first()</span><br><span class="line">            yield movie_item</span><br><span class="line"></span><br><span class="line">        hrefs_list &#x3D; sel.css(&#39;div.paginator &gt; a::attr(href)&#39;)</span><br><span class="line">        for href in hrefs_list:</span><br><span class="line">            url &#x3D; response.urljoin(href.extract())</span><br><span class="line">            yield Request(url&#x3D;url)</span><br></pre></td></tr></table></figure><p>在items.py中创建MovieItem类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import scrapy</span><br><span class="line"></span><br><span class="line">class MovieItem(scrapy.Item):</span><br><span class="line">    title &#x3D; scrapy.Field()</span><br><span class="line">    rank &#x3D; scrapy.Field()</span><br><span class="line">    subject &#x3D; scrapy.Field()</span><br></pre></td></tr></table></figure><h3 id="把数据存到excel或者数据库中"><a href="#把数据存到excel或者数据库中" class="headerlink" title="把数据存到excel或者数据库中"></a>把数据存到excel或者数据库中</h3><p>scrapy提供了一个管道，可以将数据存到excel、csv文件或者数据库中。<br>使用pip3下载并导入openpyxl，<br>在pipelines.py文件中写入以下代吗：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import openpyxl</span><br><span class="line"></span><br><span class="line">class Py3Pipeline:</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.wb &#x3D; openpyxl.Workbook()</span><br><span class="line">        self.ws &#x3D; self.wb.active</span><br><span class="line">        self.ws.title &#x3D; &#39;top250&#39;</span><br><span class="line">        self.ws.append((&#39;标题&#39;, &#39;评分&#39;, &#39;主题&#39;))</span><br><span class="line"></span><br><span class="line">    def close_spider(self, spider):</span><br><span class="line">        self.wb.save(&#39;爬虫.xlsx&#39;)</span><br><span class="line"></span><br><span class="line">    def process_item(self, item, spider):</span><br><span class="line">        title &#x3D; item.get(&#39;title&#39;, &#39;&#39;)</span><br><span class="line">        rank &#x3D; item.get(&#39;rank&#39;, &#39;&#39;)</span><br><span class="line">        subject &#x3D; item.get(&#39;subject&#39;, &#39;&#39;)</span><br><span class="line">        self.ws.append((title, rank, subject))</span><br><span class="line">        return item</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>要在settings.py文件中配置管道，打开这段注释代吗：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ITEM_PIPELINES &#x3D; &#123;</span><br><span class="line">   &#39;py3.pipelines.Py3Pipeline&#39;: 300,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="启动爬虫"><a href="#启动爬虫" class="headerlink" title="启动爬虫"></a>启动爬虫</h2><p>运行爬虫命令：scrapy crawl douban<br>然后在第一句目录下就会有douban.csv和爬虫.xlsx文件，这两个文件就是爬虫结果。<br><img src="/img/621/scrapy1.png" alt="这是图片" title="Magic Gardens"><br><img src="/img/621/scrapy2.png" alt="这是图片" title="Magic Gardens"></p><h2 id="额外配置"><a href="#额外配置" class="headerlink" title="额外配置"></a>额外配置</h2><p>到这里一个最简单使用scrapy的爬虫读取和写入程序就完成了，但还有许多额外设置可以配置比如：</p><ul><li>设置USER_AGENT防止网站认为是机器人</li><li>设置cookie来破解游戏网站需要登陆</li><li>编写自动化脚本来运行程序</li><li>下载中间件并在middlewares.py文件中配置</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> scrapy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python爬虫初探</title>
      <link href="/2022/06/10/python%E7%88%AC%E8%99%AB%E5%88%9D%E6%8E%A2/"/>
      <url>/2022/06/10/python%E7%88%AC%E8%99%AB%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在京东抢护肤品的试用装，发现一个一个手动点太麻烦了，所以想写个脚本来自动抢这些东西，顺便把爬虫的基础知识写下来。所谓生命不停，学习不止。</p><h3 id="网络爬虫是什么"><a href="#网络爬虫是什么" class="headerlink" title="网络爬虫是什么"></a>网络爬虫是什么</h3><p>网络爬虫又称网络蜘蛛、网络机器人，它是一种按照一定的规则自动浏览、检索网页信息的程序或者脚本。网络爬虫能够自动请求网页，并将所需要的数据抓取下来。通过对抓取的数据进行处理，从而提取出有价值的信息。  </p><h3 id="为什么用Python做爬虫"><a href="#为什么用Python做爬虫" class="headerlink" title="为什么用Python做爬虫"></a>为什么用Python做爬虫</h3><p>首先应该明确，不止 Python 这一种语言可以做爬虫，诸如 PHP、Java、C/C++ 都可以用来写爬虫程序，但是相比较而言 Python 做爬虫是最简单的。下面对它们的优劣势做简单对比：  </p><ul><li>PHP：对多线程、异步支持不是很好，并发处理能力较弱；Java 也经常用来写爬虫程序，但是 Java 语言本身很笨重，代码量很大，因此它对于初学者而言，入门的门槛较高；C/C++ 运行效率虽然很高，但是学习和开发成本高。写一个小型的爬虫程序就可能花费很长的时间。</li><li>而 Python 语言，其语法优美、代码简洁、开发效率高、支持多个爬虫模块，比如 urllib、requests、Bs4 等。Python 的请求模块和解析模块丰富成熟，并且还提供了强大的 Scrapy 框架，让编写爬虫程序变得更为简单。因此使用 Python 编写爬虫程序是个非常不错的选择。  <h3 id="编写爬虫的流程"><a href="#编写爬虫的流程" class="headerlink" title="编写爬虫的流程"></a>编写爬虫的流程</h3></li><li>先由 urllib 模块的 request 方法打开 URL 得到网页 HTML 对象。</li><li>使用浏览器打开网页源代码分析网页结构以及元素节点</li><li>通过 Beautiful Soup 或则正则表达式提取数据。</li><li>存储数据到本地磁盘或数据库。<br>当然也不局限于上述一种流程。编写爬虫程序，需要您具备较好的 Python 编程功底，这样在编写的过程中您才会得心应手。爬虫程序需要尽量伪装成人访问网站的样子，而非机器访问，否则就会被网站的反爬策略限制，甚至直接封杀 IP，相关知识会在后续内容介绍。  </li></ul><h2 id="第一个python程序"><a href="#第一个python程序" class="headerlink" title="第一个python程序"></a>第一个python程序</h2><p>本节编写一个最简单的爬虫程序，作为学习 Python 爬虫前的开胃小菜。<br>下面使用 Python 内置的 urllib 库获取网页的 html 信息。注意，urllib 库属于 Python 的标准库模块，无须单独安装，它是 Python 爬虫的常用模块。 </p><h3 id="获取网页html信息"><a href="#获取网页html信息" class="headerlink" title="获取网页html信息"></a>获取网页html信息</h3><p>获取响应对象<br>向百度发起请求，获取百度首页的 HTML 信息，代码如下  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#导包,发起请求使用urllib库的request请求模块</span><br><span class="line">import urllib.request</span><br><span class="line"># urlopen()向URL发请求,返回响应对象,注意url必须完整</span><br><span class="line">response&#x3D;urllib.request.urlopen(&#39;http:&#x2F;&#x2F;www.baidu.com&#x2F;&#39;)</span><br><span class="line">print(response)</span><br></pre></td></tr></table></figure><p>上述代码会返回百度首页的响应对象， 其中 urlopen() 表示打开一个网页地址。注意：请求的 url 必须带有 http 或者 https 传输协议。<br>输出结果，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;http.client.HTTPResponse object at 0x032F0F90&gt;</span><br></pre></td></tr></table></figure><p>输出HTML信息<br>在上述代码的基础上继续编写如下代码：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#提取响应内容</span><br><span class="line">html &#x3D; response.read().decode(&#39;utf-8&#39;)</span><br><span class="line">#打印响应内容</span><br><span class="line">print(html)</span><br></pre></td></tr></table></figure><p>输出结果如下，由于篇幅过长，此处只做了简单显示：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt; &lt;html&gt;&lt;head&gt;&lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html;charset&#x3D;utf-8&quot;&gt;&lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge,chrome&#x3D;1&quot;&gt;&lt;meta content&#x3D;&quot;always&quot; name&#x3D;&quot;referrer&quot;&gt;&lt;meta name&#x3D;&quot;theme-color&quot; content&#x3D;&quot;#2932e1&quot;&gt;&lt;meta name&#x3D;&quot;description&quot; content&#x3D;&quot;全球最大的中文搜索引擎、致力于让网民更便捷地获取信息，找到...&quot;&gt;...&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>通过调用 response 响应对象的 read() 方法提取 HTML 信息，该方法返回的结果是字节串类型(bytes)，因此需要使用 decode() 转换为字符串。程序完整的代码程序如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import urllib.request</span><br><span class="line"># urlopen()向URL发请求,返回响应对象</span><br><span class="line">response&#x3D;urllib.request.urlopen(&#39;http:&#x2F;&#x2F;www.baidu.com&#x2F;&#39;)</span><br><span class="line"># 提取响应内容</span><br><span class="line">html &#x3D; response.read().decode(&#39;utf-8&#39;)</span><br><span class="line"># 打印响应内容</span><br><span class="line">print(html)</span><br></pre></td></tr></table></figure><p>这样我们就实现了最简单的一个爬虫程序</p><h2 id="Python爬虫抓取网页"><a href="#Python爬虫抓取网页" class="headerlink" title="Python爬虫抓取网页"></a>Python爬虫抓取网页</h2><p>现在我们可以真实写一个实战程序来抓取网页并保存到自己的计算机。</p><h3 id="导入所需模块"><a href="#导入所需模块" class="headerlink" title="导入所需模块"></a>导入所需模块</h3><p>本节内容使用 urllib 库来编写爬虫，下面导入程序所用模块：<br>from urllib import request<br>from urllib import parse  </p><h3 id="拼接URL地址"><a href="#拼接URL地址" class="headerlink" title="拼接URL地址"></a>拼接URL地址</h3><p>定义 URL 变量，拼接 url 地址。代码如下所示：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;www.baidu.com&#x2F;s?wd&#x3D;&#123;&#125;&#39;</span><br><span class="line">#想要搜索的内容</span><br><span class="line">word &#x3D; input(&#39;请输入搜索内容:&#39;)</span><br><span class="line">params &#x3D; parse.quote(word)</span><br><span class="line">full_url &#x3D; url.format(params)</span><br></pre></td></tr></table></figure><h3 id="向URL发送请求"><a href="#向URL发送请求" class="headerlink" title="向URL发送请求"></a>向URL发送请求</h3><p>发送请求主要分为以下几个步骤：</p><ul><li>创建请求对象-Request</li><li>获取响应对象-urlopen</li><li>获取响应内容-read<br>代码如下所示：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#重构请求头</span><br><span class="line">headers &#x3D; &#123;&#39;User-Agent&#39;:&#39;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;101.0.4951.64 Safari&#x2F;537.36&#39;&#125;</span><br><span class="line">#创建请求对应</span><br><span class="line">req &#x3D; request.Request(url&#x3D;full_url,headers&#x3D;headers)</span><br><span class="line">#获取响应对象</span><br><span class="line">res &#x3D; request.urlopen(req)</span><br><span class="line">#获取响应内容</span><br><span class="line">html &#x3D; res.read().decode(&quot;utf-8&quot;)</span><br></pre></td></tr></table></figure>请求头带上自己电脑的浏览器信息，这样会识别为浏览器访问防止被反爬。<h3 id="保存为本地文件"><a href="#保存为本地文件" class="headerlink" title="保存为本地文件"></a>保存为本地文件</h3>把爬取的照片保存至本地，此处需要使用 Python 编程的文件 IO 操作，代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">filename &#x3D; word + &#39;.html&#39;</span><br><span class="line">with open(filename,&#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;) as f:</span><br><span class="line">    f.write(html)</span><br></pre></td></tr></table></figure>运行输入hexo会在本地生成hexo.html的文件，该文件内容为爬取的网页内容。<br><img src="/img/610/pc.png" alt="这是图片" title="Magic Gardens"></li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-hook-form为何如此受欢迎</title>
      <link href="/2022/05/31/react-hook-form%E4%B8%BA%E4%BD%95%E5%A6%82%E6%AD%A4%E5%8F%97%E6%AC%A2%E8%BF%8E/"/>
      <url>/2022/05/31/react-hook-form%E4%B8%BA%E4%BD%95%E5%A6%82%E6%AD%A4%E5%8F%97%E6%AC%A2%E8%BF%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>复杂表单在前端领域从来都是一个麻烦的问题，在前端三驾马车中，react由于天然缺少双向绑定的功能，所以在 react 中处理一些复杂的表单一直痛苦满满。<br>有的朋友可能会问，antd用起来不香吗？我为什么还要费劲去熟悉另外一个库呢，而且这个库靠谱吗？毫无疑问antd是非常优秀的react组件库，它内置的Form组件在中后台项目中大规模使用。在 4.x 版本重构后，表单的写法也变得更加简洁。但如工程界一直讲的，在合适的场景使用合适的轮子，我们在下方具体阐述 react-hook-form 的优势以及在哪些场景，它会更香。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>一图胜千言，两个函数即可实现react表单的数据收集<br><img src="/img/531/demo.png" alt="这是图片" title="Magic Gardens"></p><h3 id="拥抱-ref-与非受控组件"><a href="#拥抱-ref-与非受控组件" class="headerlink" title="拥抱 ref 与非受控组件"></a>拥抱 ref 与非受控组件</h3><p>从这个图中，可以看到用极少量的代码就实现了对非受控表单组件的数据收集。无须在任何时刻都被迫使用受控组件，省去了react中颇为复杂的“双向绑定”。同时，它也支持 HTML 规范里的规则以及自定义校验。由于 react-hook-form 本身的体积非常小（压缩后大约只有 5KB），所以非常适合于轻量的、使用非受控组件的场景使用。<br>同时，react-hook-form 在受控组件中用起来也很方便：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useForm, Controller &#125; from &quot;react-hook-form&quot;;</span><br><span class="line">import &#123; Input &#125; from &quot;antd&quot;;</span><br><span class="line"></span><br><span class="line">export default function Form() &#123;</span><br><span class="line">  const &#123; control &#125; &#x3D; useForm(&#123;</span><br><span class="line">    defaultValues: &#123; id: &quot;init&quot; &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Controller name&#x3D;&#39;id&#39; as&#x3D;&#123;Input&#125; control&#x3D;&#123;control&#125; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比antdv3 的getFieldDecorator方案简洁了很多，与antdv4 对比，简洁度上也不分上下。而且由于 react-hook-form 是把组件的值保存在ref中的，因此会在组件内部变化时避免整个视图重绘，这样也会给大型表单项目带来可观的性能收益。在性能敏感的场景，一方面考虑依赖的体积，另一方面考虑交互的流畅，react-hook-form 不失为一个好方案。</p><h3 id="动态增减表单项"><a href="#动态增减表单项" class="headerlink" title="动态增减表单项"></a>动态增减表单项</h3><p>在复杂表单开发中，常会遇到需要动态增减表单项的情况。比如，登记一组用户(users)，而每个 user 都有年龄(age)、名称(name)等属性，在用户填写表单的过程中，这个内容允许编辑、新增、删除、排序。react-hook-form 暴露了另外一个 custom-hooks——useFieldArray专门处理这个问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Test() &#123;</span><br><span class="line">   const &#123; control, register &#125; &#x3D; useForm();</span><br><span class="line">   const &#123; fields, append, prepend, remove, swap, move, insert &#125; &#x3D; useFieldArray(&#123;</span><br><span class="line">      control,</span><br><span class="line">      name: &quot;test&quot;,</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   return (</span><br><span class="line">      &#123;fields.map((field, index) &#x3D;&gt; (</span><br><span class="line">      &lt;input key&#x3D;&#123;field.id&#125; name&#x3D;&#123;&#96;test[$&#123;index&#125;].value&#96;&#125; ref&#x3D;&#123;register()&#125; &#x2F;&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">   );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 antd 3.x 版本中，需要额外维护一个保存组件 key 的数组，用 key 的增删代替组件的增删，十分繁琐。当然在 4.x 版本重写Form组件后，基本解决了这个问题，API 也与useFieldArray类似了。但是我个人在使用 antd 官方升级工具的过程中还是遇到了很多问题——从 3.x 升级到 4.x，大量的类型定义以及引用的路径都发生了变化。出于这点，基于typescript的 3.x 项目很难升级。所以在使用了 3.x 的老项目（支持 hooks）中，也可以考虑使用 react-hook-form 替换 antd 的Form。</p><h3 id="强大的类型支持"><a href="#强大的类型支持" class="headerlink" title="强大的类型支持"></a>强大的类型支持</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">type Inputs &#x3D; &#123;</span><br><span class="line">  example: string;</span><br><span class="line">  exampleRequired: string;</span><br><span class="line">&#125;;</span><br><span class="line">function App() &#123;</span><br><span class="line">  const &#123; register, handleSubmit, watch, error, getValues &#125; &#x3D; useForm&lt;</span><br><span class="line">    Inputs</span><br><span class="line">  &gt;();</span><br><span class="line"></span><br><span class="line">  const onSubmit: SubmitHandler&lt;Inputs&gt; &#x3D; (data) &#x3D;&gt; &#123;</span><br><span class="line">    alert(JSON.stringify(data));</span><br><span class="line">  &#125;;</span><br><span class="line">  const example &#x3D; watch(&quot;example&quot;); &#x2F;&#x2F; 类型推导为string;</span><br><span class="line">  const values &#x3D; getValues(); &#x2F;&#x2F; 类型推导为Inputs</span><br><span class="line">  return (</span><br><span class="line">    &lt;form onSubmit&#x3D;&#123;handleSubmit(onSubmit)&#125;&gt;</span><br><span class="line">      &lt;label&gt;Example&lt;&#x2F;label&gt;</span><br><span class="line">      &lt;input name&#x3D;&#39;example&#39; defaultValue&#x3D;&#39;test&#39; ref&#x3D;&#123;register&#125; &#x2F;&gt;</span><br><span class="line">      &lt;label&gt;ExampleRequired&lt;&#x2F;label&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        name&#x3D;&#39;exampleRequired&#39;</span><br><span class="line">        ref&#x3D;&#123;register(&#123; required: true, maxLength: 10 &#125;)&#125;</span><br><span class="line">      &#x2F;&gt;</span><br><span class="line">      &#123;errors.exampleRequired &amp;&amp; &lt;p&gt;This field is required&lt;&#x2F;p&gt;&#125;</span><br><span class="line">      &lt;input type&#x3D;&#39;submit&#39; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是非常令我心动的一点，表单对应的类型在整个传递过程中并没有丢失，在获取表单值的函数，如watch,getValues，setValue中还是保持了类型的正确定义。在typescript项目中，避免了更多 any 的出现，可以使你的项目尽可能保持严格的类型定义。这对于大型项目的可维护性来说很有帮助。</p><h3 id="最快速的社区支持，没有之一"><a href="#最快速的社区支持，没有之一" class="headerlink" title="最快速的社区支持，没有之一"></a>最快速的社区支持，没有之一</h3><p>react-hook-form 的社区支持是我迄今为止见过最迅速的。开源项目经过一定版本的迭代达到稳定后，一般作者会更依赖于社区内部的回复，因为作者本人实在是分身乏术了，在 issue 列表里看到几个月甚至几年前未关闭的是家常便饭。所以当第一次看到 react-hook-form 的 issues 列表我都吃惊了，没有超过一周的未关闭的bug或是question。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>如果你正在寻找react的表单方案，react-hook-form 绝对值得一试。它的优势体现在这几个方面：</p><ul><li>足够轻量，5kB的尺寸，以及使用ref保存值的特点，使它在性能敏感的场景有足够的吸引力。</li><li>对非受控组件的场景支持很好。</li><li>为动态变化的表单项提供了 custom-hooks，简洁的API帮助开发者应对复杂的场景。</li><li>强大的类型支持。</li><li>友善的社区和快速的支持。</li></ul><p>同时，它的社区也依然在成长。如果希望能在开源项目中有所贡献/锻炼英语交流能力，它也不失为一个好地方。</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> 表单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-antd table展开行实现以及自定义和踩坑</title>
      <link href="/2022/05/24/react-antd-table%E5%B1%95%E5%BC%80%E8%A1%8C%E5%AE%9E%E7%8E%B0%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B8%A9%E5%9D%91/"/>
      <url>/2022/05/24/react-antd-table%E5%B1%95%E5%BC%80%E8%A1%8C%E5%AE%9E%E7%8E%B0%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B8%A9%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在做一个权限管理的后台项目，经常涉及到树形数据展示，就用到了antd，table表格树形数据组件。记录一下使用过程的坑。  </p><h2 id="环境及配置"><a href="#环境及配置" class="headerlink" title="环境及配置"></a>环境及配置</h2><ul><li>antd -3.23.6(大版本为antd 3)</li><li>antd 3和antd 4版本对于表格来说变动很小只是把展开配置放到了一个expandable的对象里，所以只需要稍微变动就可以运用到antd v4版本  </li></ul><h2 id="antd-Table树形数据展示及使用"><a href="#antd-Table树形数据展示及使用" class="headerlink" title="antd Table树形数据展示及使用"></a>antd Table树形数据展示及使用</h2><p>使用很简单只需要数据是树形结构的就可以（一般都是children为标志，如果不是可以使用childrenColumnName树形指定key名，api文档里写的很清楚）。  </p><ul><li>1.自定义展开收起图标：<br>业务要求需要自定义展开收起（默认的不太好看）<br>实现思路：<br>利用 expandIcon，判断是否可以展开来实现  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &#39;react&#39;;</span><br><span class="line">import &#123; Table, Divider, Tag,Icon &#125; from &#39;antd&#39;;</span><br><span class="line">const data&#x3D;[</span><br><span class="line">    &#123;</span><br><span class="line">        name:&quot;破阵&quot;,</span><br><span class="line">        age:&quot;32&quot;,</span><br><span class="line">        tel:&quot;5555&quot;,</span><br><span class="line">        leve:1,</span><br><span class="line">        children:[</span><br><span class="line">            &#123;</span><br><span class="line">                name:&quot;山鬼谣&quot;,</span><br><span class="line">                age:&quot;18&quot;,</span><br><span class="line">                tel:&quot;55554&quot;,</span><br><span class="line">                leve:2,</span><br><span class="line">                children:[</span><br><span class="line">                    &#123;</span><br><span class="line">                        name:&quot;弋痕夕&quot;,</span><br><span class="line">                        age:&quot;34&quot;,</span><br><span class="line">                        tel:&quot;55554&quot;,</span><br><span class="line">                        leve:3,</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                name:&quot;天净沙&quot;,</span><br><span class="line">                age:&quot;45&quot;,</span><br><span class="line">                tel:&quot;555549&quot;,</span><br><span class="line">                leve:2,</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name:&quot;辗迟&quot;,</span><br><span class="line">        age:&quot;18&quot;,</span><br><span class="line">        tel:&quot;5555&quot;,</span><br><span class="line">        leve:1,</span><br><span class="line">        children:[]</span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line">const coumns&#x3D;[</span><br><span class="line">    &#123;</span><br><span class="line">        title: &#39;name&#39;,</span><br><span class="line">        dataIndex: &#39;name&#39;,</span><br><span class="line">        key: &#39;name&#39;,</span><br><span class="line">        render: text &#x3D;&gt; &lt;a&gt;&#123;text&#125;&lt;&#x2F;a&gt;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        title: &#39;age&#39;,</span><br><span class="line">        dataIndex: &#39;age&#39;,</span><br><span class="line">        key: &#39;age&#39;,</span><br><span class="line">        render: text &#x3D;&gt; &lt;a&gt;&#123;text&#125;&lt;&#x2F;a&gt;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        title: &#39;tel&#39;,</span><br><span class="line">        dataIndex: &#39;tel&#39;,</span><br><span class="line">        key: &#39;tel&#39;,</span><br><span class="line">        render: text &#x3D;&gt; &lt;a&gt;&#123;text&#125;&lt;&#x2F;a&gt;,</span><br><span class="line">    &#125;,</span><br><span class="line">];</span><br><span class="line">class index extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Table dataSource&#x3D;&#123;data&#125; columns&#x3D;&#123;coumns&#125; </span><br><span class="line">                    expandIcon&#x3D;&#123;(&#123;expanded, onExpand, record&#125;)&#x3D;&gt;&#123; &#x2F;&#x2F;expanded-是否可展开, onExpand-展开事件默认, record-每一项的值 设置自定义图标</span><br><span class="line">                        if(expanded)&#123;&#x2F;&#x2F;根据是否可以展开判断</span><br><span class="line">                            return  &lt;Icon type&#x3D;&quot;minus-circle&quot; onClick&#x3D;&#123;e &#x3D;&gt; onExpand(record, e)&#125;&#x2F;&gt;</span><br><span class="line">                        &#125;else&#123;</span><br><span class="line">                            return  &lt;Icon type&#x3D;&quot;plus-circle&quot; onClick&#x3D;&#123;e &#x3D;&gt; onExpand(record, e)&#125;&#x2F;&gt;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;&#125;</span><br><span class="line">                    &#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default index;</span><br></pre></td></tr></table></figure></li><li>2.业务要求默认展开<br>要知道antd里只要和default沾边的都只是初次渲染管用（比如给input设置默认值等等），所以官方给的是expandedRowKeys和onExpand结合实现。<br>实现思路：<br>expandedRowKeys和onExpand结合实现。判断是否展开，动态改变expandedRowKeys。<br>注意数据里的key必须是唯一的，否则会出现展开一个另一个也跟着展开（当然如果需求就是联动可以相同）。<br>先加上expandedRowKeys默认是展开了，但是会出现点击展开和折叠就不生效了，所以要结合onExpand实现（使用这个默认的就不生效了，默认没有子项是不展示图标的，所以还要加一个判断）  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class index extends Component &#123;</span><br><span class="line">    state &#x3D; &#123;</span><br><span class="line">        expandedRowKeys: []</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        let keyArr &#x3D; [];</span><br><span class="line">        data.map((item, index) &#x3D;&gt; &#123; &#x2F;&#x2F;这里就可以把要展开的key加进来记住必须是唯一的</span><br><span class="line">            keyArr.push(item.key)</span><br><span class="line">        &#125;)</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            expandedRowKeys: keyArr</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    onExpand &#x3D; (expanded, record) &#x3D;&gt; &#123; &#x2F;&#x2F;expanded是否展开  record每一项的值</span><br><span class="line">        let &#123; expandedRowKeys &#125; &#x3D; this.state;</span><br><span class="line">        if (expanded) &#123;</span><br><span class="line">            let arr &#x3D; expandedRowKeys;</span><br><span class="line">            arr.push(record.key);</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">                expandedRowKeys: arr</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            let arr2 &#x3D; [];</span><br><span class="line">            if (expandedRowKeys.length &gt; 0 &amp;&amp; record.key) &#123;</span><br><span class="line">                arr2 &#x3D; expandedRowKeys.filter((key) &#x3D;&gt; &#123;</span><br><span class="line">                    return key !&#x3D;&#x3D; record.key;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">                expandedRowKeys: arr2</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Table dataSource&#x3D;&#123;data&#125; columns&#x3D;&#123;coumns&#125;</span><br><span class="line">                    expandIcon&#x3D;&#123;(&#123; expanded, onExpand, record &#125;) &#x3D;&gt; &#123; &#x2F;&#x2F;expanded-是否可展开, onExpand-展开事件默认, record-每一项的值 设置自定义图标</span><br><span class="line">                        if (record.children&amp;&amp;record.children.length !&#x3D; 0) &#123;&#x2F;&#x2F;有子项加才有图标（根据自己的额业务需求变动）</span><br><span class="line">                            if (expanded) &#123;&#x2F;&#x2F;根据是否可以展开判断  </span><br><span class="line">                                return &lt;Icon type&#x3D;&quot;minus-circle&quot; onClick&#x3D;&#123;e &#x3D;&gt; onExpand(record, e)&#125; &#x2F;&gt;</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                return &lt;Icon type&#x3D;&quot;plus-circle&quot; onClick&#x3D;&#123;e &#x3D;&gt; onExpand(record, e)&#125; &#x2F;&gt;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            return &#39;&#39;</span><br><span class="line">                        &#125;</span><br><span class="line"> </span><br><span class="line">                    &#125;&#125;</span><br><span class="line">                    expandedRowKeys&#x3D;&#123;this.state.expandedRowKeys&#125;</span><br><span class="line">                    onExpand&#x3D;&#123;this.onExpand&#125;</span><br><span class="line">                &#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>3.给不同层级加颜色（类似于隔行变色）<br>实现思路：根据level来判断层级利用rowClassName来动态该改变类名  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">class index extends Component &#123;</span><br><span class="line">    state &#x3D; &#123;</span><br><span class="line">        expandedRowKeys: []</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        let keyArr &#x3D; [];</span><br><span class="line">        data.map((item, index) &#x3D;&gt; &#123; &#x2F;&#x2F;这里就可以把要展开的key加进来记住必须是唯一的</span><br><span class="line">            keyArr.push(item.key)</span><br><span class="line">        &#125;)</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            expandedRowKeys: keyArr</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    onExpand &#x3D; (expanded, record) &#x3D;&gt; &#123; &#x2F;&#x2F;expanded是否展开  record每一项的值</span><br><span class="line">        let &#123; expandedRowKeys &#125; &#x3D; this.state;</span><br><span class="line">        if (expanded) &#123;</span><br><span class="line">            let arr &#x3D; expandedRowKeys;</span><br><span class="line">            arr.push(record.key);</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">                expandedRowKeys: arr</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            let arr2 &#x3D; [];</span><br><span class="line">            if (expandedRowKeys.length &gt; 0 &amp;&amp; record.key) &#123;</span><br><span class="line">                arr2 &#x3D; expandedRowKeys.filter((key) &#x3D;&gt; &#123;</span><br><span class="line">                    return key !&#x3D;&#x3D; record.key;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">                expandedRowKeys: arr2</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    classNameFn&#x3D;(record, index)&#x3D;&gt;&#123;</span><br><span class="line">      let className&#x3D;&quot;&quot;;</span><br><span class="line">      if(record)&#123;</span><br><span class="line">          if(record.leve&#x3D;&#x3D;1)&#123;</span><br><span class="line">            className&#x3D;&quot;leve1&quot;</span><br><span class="line">          &#125;else if(record.leve&#x3D;&#x3D;2)&#123;</span><br><span class="line">            className&#x3D;&quot;leve2&quot;</span><br><span class="line">          &#125;else if(record.leve&#x3D;&#x3D;3)&#123;</span><br><span class="line">            className&#x3D;&quot;leve3&quot;</span><br><span class="line">          &#125;else&#123;</span><br><span class="line">            className&#x3D;&quot;&quot;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(className)</span><br><span class="line">      return className;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Table dataSource&#x3D;&#123;data&#125; columns&#x3D;&#123;coumns&#125;</span><br><span class="line">                    expandIcon&#x3D;&#123;(&#123; expanded, onExpand, record &#125;) &#x3D;&gt; &#123; &#x2F;&#x2F;expanded-是否可展开, onExpand-展开事件默认, record-每一项的值 设置自定义图标</span><br><span class="line">                        if (record.children&amp;&amp;record.children.length !&#x3D; 0) &#123;</span><br><span class="line">                            if (expanded) &#123;&#x2F;&#x2F;根据是否可以展开判断  </span><br><span class="line">                                return &lt;Icon type&#x3D;&quot;minus-circle&quot; onClick&#x3D;&#123;e &#x3D;&gt; onExpand(record, e)&#125; &#x2F;&gt;</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                return &lt;Icon type&#x3D;&quot;plus-circle&quot; onClick&#x3D;&#123;e &#x3D;&gt; onExpand(record, e)&#125; &#x2F;&gt;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            return &#39;&#39;</span><br><span class="line">                        &#125;</span><br><span class="line"> </span><br><span class="line">                    &#125;&#125;</span><br><span class="line">                    expandedRowKeys&#x3D;&#123;this.state.expandedRowKeys&#125; &#x2F;&#x2F;展开行</span><br><span class="line">                    onExpand&#x3D;&#123;this.onExpand&#125; &#x2F;&#x2F;展开事件</span><br><span class="line">                    rowClassName&#x3D;&#123;this.classNameFn&#125; &#x2F;&#x2F;表格行类名</span><br><span class="line">                &#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@import &#39;~antd&#x2F;es&#x2F;style&#x2F;themes&#x2F;default.less&#39;;</span><br><span class="line">.leve1&#123;</span><br><span class="line">  background: burlywood;</span><br><span class="line">&#125;</span><br><span class="line">.leve2&#123;</span><br><span class="line">    background: blue;</span><br><span class="line">&#125;</span><br><span class="line">.leve3&#123;</span><br><span class="line">    background: gray;</span><br></pre></td></tr></table></figure></li><li>4.给表格设置样式<br>给表格设置样式需要元素审查一级一级的找<br>利用：’：global’来覆盖就行  <h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>antd是很好的开源UI库，但也存在很多问题。需要根据自己的业务来，选择适合的组件。另外antd-pro是一个不错的框架（dva+umi），可以快速开发应用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> antd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React-Hooks初探</title>
      <link href="/2022/05/17/React-Hooks%E5%88%9D%E6%8E%A2/"/>
      <url>/2022/05/17/React-Hooks%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="React-Hooks-设计动机"><a href="#React-Hooks-设计动机" class="headerlink" title="React-Hooks 设计动机"></a>React-Hooks 设计动机</h2><h3 id="何谓类组件（Class-Component）"><a href="#何谓类组件（Class-Component）" class="headerlink" title="何谓类组件（Class Component）"></a>何谓类组件（Class Component）</h3><ul><li>所谓类组件，就是基于 ES6 Class 这种写法，通过继承 React.Component 得来的 React 组件<h3 id="何谓函数组件-无状态组件（Function-Component-Stateless-Component）"><a href="#何谓函数组件-无状态组件（Function-Component-Stateless-Component）" class="headerlink" title="何谓函数组件/无状态组件（Function Component/Stateless Component）"></a>何谓函数组件/无状态组件（Function Component/Stateless Component）</h3></li><li>函数组件顾名思义，就是以函数的形态存在的 React 组件。早期并没有 React-Hooks 的加持，函数组件内部无法定义和维护 state，因此它还有一个别名叫“无状态组件”。<h3 id="函数组件与类组件的对比：无关“优劣”，只谈“不同”"><a href="#函数组件与类组件的对比：无关“优劣”，只谈“不同”" class="headerlink" title="函数组件与类组件的对比：无关“优劣”，只谈“不同”"></a>函数组件与类组件的对比：无关“优劣”，只谈“不同”</h3></li><li>类组件需要继承 class，函数组件不需要；</li><li>类组件可以访问生命周期方法，函数组件不能；</li><li>类组件中可以获取到实例化后的 this，并基于这个 this 做各种各样的事情，而函数组件不可以；</li><li>类组件中可以定义并维护 state（状态），而函数组件不可以；</li></ul><h2 id="重新理解类组件：包裹在面向对象思想下的“重装战舰”"><a href="#重新理解类组件：包裹在面向对象思想下的“重装战舰”" class="headerlink" title="重新理解类组件：包裹在面向对象思想下的“重装战舰”"></a>重新理解类组件：包裹在面向对象思想下的“重装战舰”</h2><p>类组件是面向对象编程思想的一种表征。面向对象是一个老生常谈的概念了，当我们应用面向对象的时候，总是会有意或无意地做这样两件事情。</p><ul><li>封装：将一类属性和方法，“聚拢”到一个 Class 里去。</li><li>继承：新的 Class 可以通过继承现有 Class，实现对某一类属性和方法的复用。</li></ul><p>React 类组件，有一个问题——它提供了多少东西，你就需要学多少东西。假如背不住生命周期，你的组件逻辑顺序大概率会变成一团糟。“大而全”的背后，是不可忽视的学习成本。<br>再想这样一个场景：假如我现在只是需要打死一只蚊子，而不是打掉一个军队。这时候继续开动重装战舰，是不是正应了那句老话——“可以，但没有必要”。这也是类组件的一个不便，它太重了，对于解决许多问题来说，编写一个类组件实在是一个过于复杂的姿势。复杂的姿势必然带来高昂的理解成本，这也是我们所不想看到的。<br>更要命的是，由于开发者编写的逻辑在封装后是和组件粘在一起的，这就使得类<strong>组件内部的逻辑难以实现拆分和复用。</strong>如果你想要打破这个僵局，则需要进一步学习更加复杂的设计模式（比如高阶组件、Render Props 等），用更高的学习成本来交换一点点编码的灵活度。<br>这一切的一切，光是想想就让人头秃。所以说，类组件固然强大， 但它绝非万能。  </p><h2 id="深入理解函数组件：呼应-React-设计思想的“轻巧快艇”"><a href="#深入理解函数组件：呼应-React-设计思想的“轻巧快艇”" class="headerlink" title="深入理解函数组件：呼应 React 设计思想的“轻巧快艇”"></a>深入理解函数组件：呼应 React 设计思想的“轻巧快艇”</h2><p>相比于类组件，函数组件肉眼可见的特质自然包括轻量、灵活、易于组织和维护、较低的学习成本等。<br>类组件和函数组件之间，纵有千差万别，但最不能够被我们忽视掉的，是心智模式层面的差异，是面向对象和函数式编程这两套不同的设计思想之间的差异。<br>说得更具体一点，函数组件更加契合 React 框架的设计理念。何出此言？不要忘了这个赫赫有名的 React 公式：<br><img src="/img/517/React.png" alt="这是图片" title="Magic Gardens"></p><h2 id="Hooks-的本质：一套能够使函数组件更强大、更灵活的“钩子”"><a href="#Hooks-的本质：一套能够使函数组件更强大、更灵活的“钩子”" class="headerlink" title="Hooks 的本质：一套能够使函数组件更强大、更灵活的“钩子”"></a>Hooks 的本质：一套能够使函数组件更强大、更灵活的“钩子”</h2><p>React-Hooks 是什么？它是一套能够使函数组件更强大、更灵活的“钩子”。<br>前面我们已经说过，函数组件比起类组件“少”了很多东西，比如生命周期、对 state 的管理等。这就给函数组件的使用带来了非常多的局限性，导致我们并不能使用函数这种形式，写出一个真正的全功能的组件。<br>React-Hooks 的出现，就是为了帮助函数组件补齐这些（相对于类组件来说）缺失的能力。<br>如果说函数组件是一台轻巧的快艇，那么 React-Hooks 就是一个内容丰富的零部件箱。“重装战舰”所预置的那些设备，这个箱子里基本全都有，同时它还不强制你全都要，而是允许你自由地选择和使用你需要的那些能力，然后将这些能力以 Hook（钩子）的形式“钩”进你的组件里，从而定制出一个最适合你的“专属战舰”。  </p><h2 id="从核心-API-看-Hooks-的基本形态"><a href="#从核心-API-看-Hooks-的基本形态" class="headerlink" title="从核心 API 看 Hooks 的基本形态"></a>从核心 API 看 Hooks 的基本形态</h2><h3 id="useState-：为函数组件引入状态"><a href="#useState-：为函数组件引入状态" class="headerlink" title="useState()：为函数组件引入状态"></a>useState()：为函数组件引入状态</h3><p>早期的函数组件相比于类组件，其一大劣势是缺乏定义和维护 state 的能力，而 state（状态）作为 React 组件的灵魂，必然是不可省略的。因此 React-Hooks 在诞生之初，就优先考虑了对 state 的支持。useState 正是这样一个能够为函数组件引入状态的 API。<br>有了 useState 后，我们就可以直接在函数组件里引入 state。</p><h3 id="useState-快速上手"><a href="#useState-快速上手" class="headerlink" title="useState 快速上手"></a>useState 快速上手</h3><p>从用法上看，useState 返回的是一个数组，数组的第一个元素对应的是我们想要的那个 state 变量，第二个元素对应的是能够修改这个变量的 API。我们可以通过数组解构的语法，将这两个元素取出来，并且按照我们自己的想法命名。一个典型的调用示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [state, setState] &#x3D; useState(initialState);</span><br></pre></td></tr></table></figure><p>在这个示例中，我们给自己期望的那个状态变量命名为 state，给修改 state 的 API 命名为 setState。useState 中传入的 initialState 正是 state 的初始值。后续我们可以通过调用 setState，来修改 state 的值，像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setState(newState)</span><br></pre></td></tr></table></figure><p>状态更新后会触发渲染层面的更新，这点和类组件是一致的。<br>这里需要向初学者强调的一点是：状态和修改状态的 API 名都是可以自定义的。比如在上文的 Demo 中，就分别将其自定义为 text 和 setText：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [text, setText] &#x3D; useState(&quot;初始文本&quot;);</span><br></pre></td></tr></table></figure><p>“set + 具体变量名”这种命名形式，可以帮助我们快速地将 API 和它对应的状态建立逻辑联系。<br>当我们在函数组件中调用 React.useState 的时候，实际上是给这个组件关联了一个状态——注意，是“一个状态”而不是“一批状态”。这一点是相对于类组件中的 state 来说的。在类组件中，我们定义的 state 通常是一个这样的对象，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  this.state &#123;</span><br><span class="line">  text: &quot;初始文本&quot;,</span><br><span class="line">  length: 10000,</span><br><span class="line">  author: [&quot;xiuyan&quot;, &quot;cuicui&quot;, &quot;yisi&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个对象是“包容万物”的：整个组件的状态都在 state 对象内部做收敛，当我们需要某个具体状态的时候，会通过 this.state.xxx 这样的访问对象属性的形式来读取它。<br>而在 useState 这个钩子的使用背景下，state 就是单独的一个状态，它可以是任何你需要的 JS 类型。像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义为数组</span><br><span class="line">const [author, setAuthor] &#x3D; useState([&quot;xiuyan&quot;, &quot;cuicui&quot;, &quot;yisi&quot;]);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 定义为数值</span><br><span class="line">const [length, setLength] &#x3D; useState(100);</span><br><span class="line">&#x2F;&#x2F; 定义为字符串</span><br><span class="line">const [text, setText] &#x3D; useState(&quot;初始文本&quot;)</span><br></pre></td></tr></table></figure><p>你还可以定义为布尔值、对象等，都是没问题的。它就像类组件中 state 对象的某一个属性一样，对应着一个单独的状态，允许你存储任意类型的值。  </p><h3 id="useEffect-：允许函数组件执行副作用操作"><a href="#useEffect-：允许函数组件执行副作用操作" class="headerlink" title="useEffect()：允许函数组件执行副作用操作"></a>useEffect()：允许函数组件执行副作用操作</h3><p>函数组件相比于类组件来说，最显著的差异就是 state 和生命周期的缺失。useState 为函数组件引入了 state，而 useEffect 则在一定程度上弥补了生命周期的缺席。<br>useEffect 能够为函数组件引入副作用。过去我们习惯放在 componentDidMount、componentDidUpdate 和 componentWillUnmount 三个生命周期里来做的事，现在可以放在 useEffect 里来做，比如操作 DOM、订阅事件、调用外部 API 获取数据等。  </p><h2 id="Hooks-是如何帮助我们升级工作模式的"><a href="#Hooks-是如何帮助我们升级工作模式的" class="headerlink" title="Hooks 是如何帮助我们升级工作模式的"></a>Hooks 是如何帮助我们升级工作模式的</h2><h3 id="1-告别难以理解的-Class：把握-Class-的两大“痛点”"><a href="#1-告别难以理解的-Class：把握-Class-的两大“痛点”" class="headerlink" title="1. 告别难以理解的 Class：把握 Class 的两大“痛点”"></a>1. 告别难以理解的 Class：把握 Class 的两大“痛点”</h3><p>为了解决 this 不符合预期的问题，各路前端也是各显神通，之前用 bind、现在推崇箭头函数。但不管什么招数，本质上都是在用实践层面的约束来解决设计层面的问题。好在现在有了 Hooks，一切都不一样了，我们可以在函数组件里放飞自我（毕竟函数组件是不用关心 this 的）哈哈，解放啦<br>至于生命周期，它带来的麻烦主要有以下两个方面：</p><ul><li>学习成本</li><li>不合理的逻辑规划方式</li></ul><h3 id="2-Hooks-如何实现更好的逻辑拆分"><a href="#2-Hooks-如何实现更好的逻辑拆分" class="headerlink" title="2. Hooks 如何实现更好的逻辑拆分"></a>2. Hooks 如何实现更好的逻辑拆分</h3><p>生命周期函数常常做一些奇奇怪怪的事情：比如在 componentDidMount 里获取数据，在 componentDidUpdate 里根据数据的变化去更新 DOM 等。如果说你只用一个生命周期做一件事，那好像也还可以接受，但是往往在一个稍微成规模的 React 项目中，一个生命周期不止做一件事情。<br>像这样的生命周期函数，它的体积过于庞大，做的事情过于复杂，会给阅读和维护者带来很多麻烦。最重要的是，这些事情之间看上去毫无关联，逻辑就像是被“打散”进生命周期里了一样。比如，设置订阅和卸载订阅的逻辑，虽然它们在逻辑上是有强关联的，但是却只能被分散到不同的生命周期函数里去处理，这无论如何也不能算作是一个非常合理的设计。<br>而在 Hooks 的帮助下，我们完全可以把这些繁杂的操作按照逻辑上的关联拆分进不同的函数组件里：我们可以有专门管理订阅的函数组件、专门处理 DOM 的函数组件、专门获取数据的函数组件等。Hooks 能够帮助我们实现业务逻辑的聚合，避免复杂的组件和冗余的代码。  </p><h3 id="3-状态复用：Hooks-将复杂的问题变简单"><a href="#3-状态复用：Hooks-将复杂的问题变简单" class="headerlink" title="3. 状态复用：Hooks 将复杂的问题变简单"></a>3. 状态复用：Hooks 将复杂的问题变简单</h3><p>过去我们复用状态逻辑，靠的是 HOC（高阶组件）和 Render Props 这些组件设计模式，这是因为 React 在原生层面并没有为我们提供相关的途径。但这些设计模式并非万能，它们在实现逻辑复用的同时，也破坏着组件的结构，其中一个最常见的问题就是“嵌套地狱”现象。<br>Hooks 可以视作是 React 为解决状态逻辑复用这个问题所提供的一个原生途径。现在我们可以通过自定义 Hook，达到既不破坏组件结构、又能够实现逻辑复用的效果。  </p><h3 id="保持清醒：Hooks-并非万能"><a href="#保持清醒：Hooks-并非万能" class="headerlink" title="保持清醒：Hooks 并非万能"></a>保持清醒：Hooks 并非万能</h3><p>尽管我们已经说了这么多 Hooks 的“好话”，尽管 React 团队已经用脚投票表明了对函数组件的积极态度，但我们还是要谨记这样一个基本的认知常识：事事无绝对，凡事皆有两面性。更何况 React 仅仅是推崇函数组件，并没有“拉踩”类组件，甚至还官宣了“类组件和函数组件将继续共存”这件事情。这些都在提醒我们，在认识到 Hooks 带来的利好的同时，还需要认识到它的局限性。<br>关于 Hooks 的局限性，目前社区鲜少有人讨论。这里我想结合团队开发过程当中遇到的一些瓶颈，和你分享实践中的几点感受：</p><ul><li>Hooks 暂时还不能完全地为函数组件补齐类组件的能力</li><li>“轻量”几乎是函数组件的基因，这可能会使它不能够很好地消化“复杂”</li><li>Hooks 在使用层面有着严格的规则约束</li></ul>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> Hooks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3之Composition API详解</title>
      <link href="/2022/05/05/Vue3%E4%B9%8BComposition-API%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/05/05/Vue3%E4%B9%8BComposition-API%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><code>Composition API</code>也叫组合式API，是Vue3.x的新特性。  </p><p>通俗的讲：  </p><p>没有<code>Composition API</code>之前vue相关业务的代码需要配置到option的特定的区域，中小型项目是没有问题的，但是在大型项目中会导致后期的维护性比较复杂，同时代码可复用性不高。Vue3.x中的composition-api就是为了解决这个问题而生的</p><p>compositon api提供了以下几个函数：</p><ul><li>setup</li><li>ref</li><li>reactive</li><li>watcheffect</li><li>watch</li><li>computed</li><li>toRefs</li><li>生命周期的hooks</li></ul><h2 id="一、setup组件选项"><a href="#一、setup组件选项" class="headerlink" title="一、setup组件选项"></a>一、setup组件选项</h2><h3 id="1-Props"><a href="#1-Props" class="headerlink" title="1. Props"></a>1. Props</h3><ul><li>setup 函数中的第一个参数是 props。正如在一个标准组件中所期望的那样，setup 函数中的 props 是响应式的，当传入新的 prop 时，它将被更新<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    title: String</span><br><span class="line">  &#125;,</span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    console.log(props.title)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>但是，因为 props 是响应式的，你不能使用 ES6 解构，因为它会消除 prop 的响应性<br>如果需要解构 prop，可以通过使用 setup 函数中的 toRefs 来安全地完成此操作。</li></ul><h3 id="2-上下文"><a href="#2-上下文" class="headerlink" title="2. 上下文"></a>2. 上下文</h3><ul><li>传递给 setup 函数的第二个参数是 context。context 是一个普通的 JavaScript 对象，它暴露三个组件的 property  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  export default &#123;</span><br><span class="line">  setup(props, context) &#123;</span><br><span class="line">    &#x2F;&#x2F; Attribute (非响应式对象)</span><br><span class="line">    console.log(context.attrs)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 插槽 (非响应式对象)</span><br><span class="line">    console.log(context.slots)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 触发事件 (方法)</span><br><span class="line">    console.log(context.emit)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>context 是一个普通的 JavaScript 对象，也就是说，它不是响应式的，这意味着你可以安全地对 context 使用 ES6 解构  </li></ul><h3 id="3-setup组件的-property"><a href="#3-setup组件的-property" class="headerlink" title="3. setup组件的 property"></a>3. setup组件的 property</h3><p>执行 setup 时，组件实例尚未被创建。因此，你只能访问以下 property：</p><ul><li>props</li><li>attrs</li><li>slots</li><li>emit</li></ul><p>换句话说，你将无法访问以下组件选项：</p><ul><li>data</li><li>methods</li><li>computed</li></ul><h3 id="4-ref-reactive-以及setup结合模板使用"><a href="#4-ref-reactive-以及setup结合模板使用" class="headerlink" title="4. ref reactive 以及setup结合模板使用"></a>4. ref reactive 以及setup结合模板使用</h3><ul><li>ref用来定义响应式的 字符串、 数值、 数组、Bool类型</li><li>reactive 用来定义响应式的对象</li></ul><h3 id="5-使用-this"><a href="#5-使用-this" class="headerlink" title="5. 使用 this"></a>5. 使用 this</h3><ul><li>在 setup() 内部，this 不会是该活跃实例的引用，因为 setup() 是在解析其它组件选项之前被调用的，所以 setup() 内部的 this 的行为与其它选项中的 this 完全不同。这在和其它选项式 API 一起使用 setup() 时可能会导致混淆</li></ul><h2 id="二、toRefs-解构响应式对象数据"><a href="#二、toRefs-解构响应式对象数据" class="headerlink" title="二、toRefs - 解构响应式对象数据"></a>二、toRefs - 解构响应式对象数据</h2><ul><li>把一个响应式对象转换成普通对象，该普通对象的每个 property 都是一个 ref ，和响应式对象 property 一一对应<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  &lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;h1&gt;解构响应式对象数据&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;p&gt;Username: &#123;&#123;username&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;Age: &#123;&#123;age&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;</span><br><span class="line">    reactive,</span><br><span class="line">    toRefs</span><br><span class="line">&#125; from &quot;vue&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    name: &quot;解构响应式对象数据&quot;,</span><br><span class="line">    setup() &#123;</span><br><span class="line">        const user &#x3D; reactive(&#123;</span><br><span class="line">            username: &quot;张三&quot;,</span><br><span class="line">            age: 10000,</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        return &#123;</span><br><span class="line">            ...toRefs(user)</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="三、computed-计算属性"><a href="#三、computed-计算属性" class="headerlink" title="三、computed - 计算属性"></a>三、computed - 计算属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">  &lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;h1&gt;解构响应式对象数据+computed&lt;&#x2F;h1&gt;</span><br><span class="line"></span><br><span class="line">    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;firstName&quot; placeholder&#x3D;&quot;firstName&quot; &#x2F;&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;lastName&quot; placeholder&#x3D;&quot;lastName&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &#123;&#123;fullName&#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;</span><br><span class="line">    reactive,</span><br><span class="line">    toRefs,</span><br><span class="line">    computed</span><br><span class="line">&#125; from &quot;vue&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    name: &quot;解构响应式对象数据&quot;,</span><br><span class="line">    setup() &#123;</span><br><span class="line">        const user &#x3D; reactive(&#123;</span><br><span class="line">            firstName: &quot;&quot;,</span><br><span class="line">            lastName: &quot;&quot;,</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        const fullName &#x3D; computed(() &#x3D;&gt; &#123;</span><br><span class="line">            return user.firstName + &quot; &quot; + user.lastName</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        return &#123;</span><br><span class="line">            ...toRefs(user),</span><br><span class="line">            fullName</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="四、readonly-“深层”的只读代理"><a href="#四、readonly-“深层”的只读代理" class="headerlink" title="四、readonly “深层”的只读代理"></a>四、readonly “深层”的只读代理</h2><ul><li>传入一个对象（响应式或普通）或 ref，返回一个原始对象的只读代理。一个只读的代理是“深层的”，对象内部任何嵌套的属性也都是只读的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  &lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;readonly - “深层”的只读代理&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;p&gt;original.count: &#123;&#123;original.count&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;copy.count: &#123;&#123;copy.count&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; reactive, readonly &#125; from &quot;vue&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Readonly&quot;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const original &#x3D; reactive(&#123; count: 0 &#125;);</span><br><span class="line">    const copy &#x3D; readonly(original);</span><br><span class="line"></span><br><span class="line">    setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">      original.count++;</span><br><span class="line">      copy.count++; &#x2F;&#x2F; 报警告，Set operation on key &quot;count&quot; failed: target is readonly. Proxy &#123;count: 1&#125;</span><br><span class="line">    &#125;, 1000);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return &#123; original, copy &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="五、watchEffect"><a href="#五、watchEffect" class="headerlink" title="五、watchEffect"></a>五、watchEffect</h2><ul><li>在响应式地跟踪其依赖项时立即运行一个函数，并在更改依赖项时重新运行它。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">  &lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;h1&gt;watchEffect - 侦听器&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;data.count&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;stop&quot;&gt;手动关闭侦听器&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;</span><br><span class="line">    reactive,</span><br><span class="line">    watchEffect</span><br><span class="line">&#125; from &quot;vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &quot;WatchEffect&quot;,</span><br><span class="line">    setup() &#123;</span><br><span class="line">        const data &#x3D; reactive(&#123;</span><br><span class="line">            count: 1,</span><br><span class="line">            num: 1</span><br><span class="line">        &#125;);</span><br><span class="line">        const stop &#x3D; watchEffect(() &#x3D;&gt; console.log(&#96;侦听器：$&#123;data.count&#125;&#96;));</span><br><span class="line">        setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">            data.count++;</span><br><span class="line">        &#125;, 1000);</span><br><span class="line">        return &#123;</span><br><span class="line">            data,</span><br><span class="line">            stop</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="六、watch-、watch-与watchEffect区别"><a href="#六、watch-、watch-与watchEffect区别" class="headerlink" title="六、watch 、watch 与watchEffect区别"></a>六、watch 、watch 与watchEffect区别</h2><p>对比watchEffect，watch允许我们:</p><ul><li>懒执行，也就是说仅在侦听的源变更时才执行回调；</li><li>更明确哪些状态的改变会触发侦听器重新运行；</li><li>访问侦听状态变化前后的值</li></ul><h2 id="七、组合式api生命周期钩子"><a href="#七、组合式api生命周期钩子" class="headerlink" title="七、组合式api生命周期钩子"></a>七、组合式api生命周期钩子</h2><p><img src="/img/505/hook.png" alt="这是图片" title="Magic Gardens">  </p><ul><li>因为 setup 是围绕 beforeCreate 和 created 生命周期钩子运行的，所以不需要显式地定义它们。换句话说，在这些钩子中编写的任何代码都应该直接在 setup 函数中编写</li></ul><h2 id="八、Provider-Inject"><a href="#八、Provider-Inject" class="headerlink" title="八、Provider Inject"></a>八、Provider Inject</h2><p>没用过……</p>]]></content>
      
      
      <categories>
          
          <category> Vue3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue3 </tag>
            
            <tag> Composition API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信h5网页跳转小程序方案</title>
      <link href="/2022/04/27/%E5%BE%AE%E4%BF%A1h5%E7%BD%91%E9%A1%B5%E8%B7%B3%E8%BD%AC%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%96%B9%E6%A1%88/"/>
      <url>/2022/04/27/%E5%BE%AE%E4%BF%A1h5%E7%BD%91%E9%A1%B5%E8%B7%B3%E8%BD%AC%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h2 id="接入要求"><a href="#接入要求" class="headerlink" title="接入要求"></a>接入要求</h2><ul><li>主体要求: 仅开放给已认证的服务号</li><li>系统要求：微信版本要求为：7.0.12及以上。系统版本要求为：iOS 10.3及以上、Android 5.0及以上</li></ul><h2 id="接入微信JS-SDK"><a href="#接入微信JS-SDK" class="headerlink" title="接入微信JS-SDK"></a>接入微信JS-SDK</h2><h3 id="包使用方式"><a href="#包使用方式" class="headerlink" title="包使用方式"></a>包使用方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;weixin-js-sdk&quot;: &quot;^1.6.0&quot;</span><br></pre></td></tr></table></figure><h3 id="直接在页面上使用"><a href="#直接在页面上使用" class="headerlink" title="直接在页面上使用"></a>直接在页面上使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  在需要调用JS接口的页面引入如下JS文件：http:&#x2F;&#x2F;res.wx.qq.com&#x2F;open&#x2F;js&#x2F;jweixin-1.6.0.js （支持https）  </span><br><span class="line">  wx.config(&#123;</span><br><span class="line">  appId: &#39;&#39;,</span><br><span class="line">  debug: true,</span><br><span class="line">  timestamp: &#39;&#39;,</span><br><span class="line">  nonceStr: &#39;&#39;,</span><br><span class="line">  signature: &#39;&#39;,</span><br><span class="line">  jsApiList: [],</span><br><span class="line">  openTagList: [&#39;wx-open-launch-app&#39;,&#39;wx-open-launch-weapp&#39;] &#x2F;&#x2F; 获取开放标签权限</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h3><ul><li><code>wx.config</code> 内列出使用到的 <code>openTagList</code></li><li>符合开放平台列出的要求</li><li>app 需要根据接入微信 sdk</li></ul><h2 id="在vue中使用例子"><a href="#在vue中使用例子" class="headerlink" title="在vue中使用例子"></a>在vue中使用例子</h2><h3 id="第1步-在main-js中设置"><a href="#第1步-在main-js中设置" class="headerlink" title="第1步 在main.js中设置"></a>第1步 在main.js中设置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 忽略微信自定义标签</span><br><span class="line">Vue.config.ignoredElements &#x3D; [&#39;wx-open-launch-weapp&#39;,&#39;wx-open-launch-app&#39;]</span><br></pre></td></tr></table></figure><h3 id="第2步-获取微信版本"><a href="#第2步-获取微信版本" class="headerlink" title="第2步 获取微信版本"></a>第2步 获取微信版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取微信版本</span><br><span class="line">&#x2F;&#x2F; return eg. 7.0.16.1600</span><br><span class="line">getWeixinVersion() &#123;</span><br><span class="line">  return navigator.userAgent.match(&#x2F;MicroMessenger\&#x2F;([\d\.]+)&#x2F;i)[1]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  created()&#123;</span><br><span class="line">  &#x2F;&#x2F; 微信版本号大于 7.0.12 开放标签才可进行</span><br><span class="line">  const wxVersion &#x3D; this.isWechat() &amp;&amp; this.getWeixinVersion() || &#39;&#39;</span><br><span class="line">  if(wxVersion)&#123;</span><br><span class="line">    let v &#x3D; wxVersion.split(&#39;.&#39;)</span><br><span class="line">    if(v[0]&gt;&#x3D;7)&#123;</span><br><span class="line">      if(v[1]&gt;&#x3D;0)&#123;</span><br><span class="line">        if(v[2]&gt;&#x3D;12)&#123;</span><br><span class="line">          this.enableLaunchWeapp &#x3D; true</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="第3步-在页面上展示"><a href="#第3步-在页面上展示" class="headerlink" title="第3步 在页面上展示"></a>第3步 在页面上展示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  &lt;div v-if&#x3D;&quot;enableLaunchWeapp&quot;&gt;</span><br><span class="line">  &lt;wx-open-launch-weapp</span><br><span class="line">    id&#x3D;&quot;launch-btn&quot;</span><br><span class="line">    username&#x3D;&quot;gh_ed1212c48129d7fa3d&quot;</span><br><span class="line">    path&#x3D;&quot;&#x2F;pages&#x2F;home&#x2F;index.html&quot;</span><br><span class="line">  &gt;</span><br><span class="line">    &lt;script type&#x3D;&quot;text&#x2F;wxtag-template&quot;&gt;</span><br><span class="line">      &lt;style&gt;</span><br><span class="line">        .goodsname &#123;</span><br><span class="line">          font-size: 16px;</span><br><span class="line">          color: #333333;</span><br><span class="line">          font-weight: 600;</span><br><span class="line">          line-height: 24px;</span><br><span class="line">          margin-bottom: 5px;</span><br><span class="line">        &#125;</span><br><span class="line">      &lt;&#x2F;style&gt;</span><br><span class="line">      &lt;h1 class&#x3D;&quot;goodsname&quot;&gt;&#123;&#123; goodsInfo.goodsName &#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">  &lt;&#x2F;wx-open-launch-weapp&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;h1 v-else&gt;&#123;&#123; goodsInfo.goodsName &#125;&#125;&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure><h3 id="需要注意"><a href="#需要注意" class="headerlink" title="需要注意"></a>需要注意</h3><ul><li>在vue中需要加上 <code>&lt;script type=&quot;text/wxtag-template”&gt;&lt;/script&gt;</code>包裹元素，否则按钮不能展示</li><li>username为小程序原始id，需要在小程序后台设置那里获取</li><li>path是打开小程序的指定页面，需要加上.html 如<code>/pages/home/index.html</code></li><li>style中样式写法需要注意，goods-name 好像不支持，需要这样写goodsname，只支持px格式</li></ul><h3 id="第4步-监听开发标签回调事件"><a href="#第4步-监听开发标签回调事件" class="headerlink" title="第4步 监听开发标签回调事件"></a>第4步 监听开发标签回调事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  mounted()&#123;</span><br><span class="line">  var btn &#x3D; document.getElementById(&#39;launch-btn&#39;)</span><br><span class="line">  btn.addEventListener(&#39;launch&#39;, e &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;success&#39;);</span><br><span class="line">  &#125;);</span><br><span class="line">  btn.addEventListener(&#39;error&#39;,  e &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;fail&#39;, e.detail);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> h5 </tag>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>serverless及小程序云开发实践总结</title>
      <link href="/2022/04/24/serverless%E5%8F%8A%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/"/>
      <url>/2022/04/24/serverless%E5%8F%8A%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Serverless-架构详解"><a href="#一、Serverless-架构详解" class="headerlink" title="一、Serverless 架构详解"></a>一、Serverless 架构详解</h2><h3 id="1-1-什么是serverless"><a href="#1-1-什么是serverless" class="headerlink" title="1.1 什么是serverless"></a>1.1 什么是serverless</h3><ul><li>Serverless又名无服务器,所谓无服务器并非是说不需要依赖和依靠服务器等资源,而是开发者再也不用过多考虑服务器的问题,可以更专注在产品代码上。</li><li>Serverless是一种软件系统架构的思想和方法，它不是软件框架、类库或者工具。它与传统架构的不同之处在于，完全由第三方管理，由事件触发，存在于无状态(Stateless)、 暂存(可能只存在于一次调用的过程中)计算容器内。构建无服务器应用程序意味着开发者可以专注在产品代码上，而无须管理和操作云端或本地的服务器或运行时(运行时通俗的讲 就是运行环境，比如 nodejs环境，java 环境，php 环境)。Serverless 真正做到了部署应用 无需涉及基础设施的建设，自动构建、部署和启动服务。</li></ul><h3 id="1-2-Serverless要解决什么？"><a href="#1-2-Serverless要解决什么？" class="headerlink" title="1.2 Serverless要解决什么？"></a>1.2 Serverless要解决什么？</h3><ul><li>完整的后端应用上线流程</li><li>机器管理运维：扩缩容</li><li>降级、熔断、限流</li><li>域名、性能、监控</li></ul><h3 id="1-3-Serverless做什么事？"><a href="#1-3-Serverless做什么事？" class="headerlink" title="1.3 Serverless做什么事？"></a>1.3 Serverless做什么事？</h3><ul><li>我们只需要关心业务代码，不需要关心服务器的基础设施。</li></ul><h3 id="1-4-传统服务器架构-VS-Serverless架构"><a href="#1-4-传统服务器架构-VS-Serverless架构" class="headerlink" title="1.4 传统服务器架构 VS Serverless架构"></a>1.4 传统服务器架构 VS Serverless架构</h3><ul><li>传统服务器架构：<br><img src="/img/424/ct.png" alt="这是图片" title="Magic Gardens"></li><li>Serverless架构：<br><img src="/img/424/sl.png" alt="这是图片" title="Magic Gardens"></li></ul><h3 id="1-5-Serverless架构的优缺点"><a href="#1-5-Serverless架构的优缺点" class="headerlink" title="1.5 Serverless架构的优缺点"></a>1.5 Serverless架构的优缺点</h3><p>优势</p><ul><li>无运维：我们不需要购买服务器，直接可进行</li><li>资源分配: 在 Serverless 架构中，你不用关心应用运行的资源(比如服务配置、磁盘大小)只提供一份代码就行。</li><li>计费方式: 在Serverless 架构中，计费方式按实际使用量计费(比如函数调用次数、运 行时长)，不按传统的执行代码所需的资源计费(比如固定 CPU)。计费粒度也精确到了毫 秒级，而不是传统的小时级别。个别云厂商推出了每个月的免费额度，比如腾讯云提供了每 个月 40 万 GBs 的资源使用额度和 100 万次调用次数的免费额度。中小企业的网站访问量不 是特别大的话完全可以免费使用。</li><li>弹性伸缩:Serverless 架构的弹性伸缩更自动化、更精确，可以快速根据业务并发扩容更 多的实例，甚至允许缩容到零实例状态来实现零费用，对用户来说是完全无感知的。而传统 架构对服务器(虚拟机)进行扩容，虚拟机的启动速度也比较慢，需要几分钟甚至更久。  </li></ul><p>不足</p><ul><li>ServerLess 不仅仅是一门技术也是一种理念和微服务一样，很多老系统不能直接上 ServerLess，得相应的进行升级和拆解才能更好的适应 ServerLess，这是一个门槛。</li><li>同时 ServerLess 针对开发语言的可定制性和可开放性，ServerLess 会选择处于稳定版的语言且更新具有一定的滞后性，特别是 Node.JS 这样的版本更新帝，最新稳定版是10，但是提供的却是8。同时如果对语言有底层的修改而无法通过 Plugin 实现同样也无法适应相关场景。</li><li>不适合长时间的进行计算处理的场景，ServerLess 是产生计算后按时间计费的，适合那些触发类短时间计算的，如果有长时间进行计算的场景就不适合。</li></ul><h2 id="二、微信小程序云开发"><a href="#二、微信小程序云开发" class="headerlink" title="二、微信小程序云开发"></a>二、微信小程序云开发</h2><h3 id="2-1-小程序传统开发模式"><a href="#2-1-小程序传统开发模式" class="headerlink" title="2.1 小程序传统开发模式"></a>2.1 小程序传统开发模式</h3><p><img src="/img/424/ct2.png" alt="这是图片" title="Magic Gardens"></p><h3 id="2-2-云开发正在改变小程序的开发模式"><a href="#2-2-云开发正在改变小程序的开发模式" class="headerlink" title="2.2 云开发正在改变小程序的开发模式"></a>2.2 云开发正在改变小程序的开发模式</h3><p>云开发是什么</p><ul><li>简单的说，就是云开发是一套综合类服务的技术产品，通常开发一个完整的应用（小程序也好，Web、移动应用也好）都需要数据库、存储、CDN、后端函数、静态托管、用户登录等等，但是云开发将这些服务都集成到了一起，而且以一种全新的开发方式，让开发一个应用更加快速、方便、便宜且强大，引领未来技术开发的新趋势。<br><img src="/img/424/ykf.png" alt="这是图片" title="Magic Gardens">    </li></ul><p>云开发优势</p><ul><li>快速上线</li><li>更加专注我们的业务</li><li>独立开发一个完整的小程序，云开发提供非常丰富的接口，我们通过这些接口很方便文件上传等操作</li><li>不需要考虑运维等问题，云开发是弹性扩容的</li><li>数据更安全</li></ul><p>小程序云开发提供哪些基础能力<br><img src="/img/424/ykf2.png" alt="这是图片" title="Magic Gardens"></p><h3 id="2-3-小程序云开发项目的创建与配置"><a href="#2-3-小程序云开发项目的创建与配置" class="headerlink" title="2.3 小程序云开发项目的创建与配置"></a>2.3 小程序云开发项目的创建与配置</h3><ul><li>创建项目时选择使用云开发</li><li>点击开发者工具的云开发开通云开发环境</li><li>在app.js的env: ‘my-env-id’处改成你的环境ID</li></ul><p>云函数部署与上传</p><ul><li>右键云函数目录，选择在终端中打开，输入npm install命令下载依赖文件</li><li>然后再右键云函数目录，点击“创建并部署：所有文件”</li><li>在云开发控制台–云函数–云函数列表查看云函数是否部署成功。</li></ul><p>云存储使用图片上传<br><img src="/img/424/cc.png" alt="这是图片" title="Magic Gardens">  </p><p>云数据库使用<br><img src="/img/424/sjk.png" alt="这是图片" title="Magic Gardens"> </p>]]></content>
      
      
      <categories>
          
          <category> serverless </category>
          
      </categories>
      
      
        <tags>
            
            <tag> serverless </tag>
            
            <tag> 小程序云开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用shadowsocks搭建一个免费的翻墙服务</title>
      <link href="/2022/04/22/%E4%BD%BF%E7%94%A8shadowsocks%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%85%8D%E8%B4%B9%E7%9A%84%E7%BF%BB%E5%A2%99%E6%9C%8D%E5%8A%A1/"/>
      <url>/2022/04/22/%E4%BD%BF%E7%94%A8shadowsocks%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%85%8D%E8%B4%B9%E7%9A%84%E7%BF%BB%E5%A2%99%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、vpn和代理的区别"><a href="#一、vpn和代理的区别" class="headerlink" title="一、vpn和代理的区别"></a>一、vpn和代理的区别</h2><h3 id="vpn"><a href="#vpn" class="headerlink" title="vpn"></a>vpn</h3><ul><li>VPN英文全称：Virtual Private Network（虚拟专用网络）。VPN被定义为通过一个公用互联网络建立一个临时的、安全的连接，是一条穿过混乱的公用网络的安全、稳定隧道，使用这条隧道可以对数据进行几倍加密达到安全使用互联网的目的。<br>具体的实现方式包括PPTP,L2TP,IPsec和openvpn。vpn是一种加密通讯技术，目的是保证数据传输完全和网络匿名。  </li></ul><h3 id="代理-proxy"><a href="#代理-proxy" class="headerlink" title="代理(proxy)"></a>代理(proxy)</h3><ul><li>反向代理：反向代理的主要作用为服务器做缓存和负载均衡。反向代理的负载均衡是指在多个真正的服务器之前架设一个代理服务器，用户所有的数据都发给代理服务器，代理服务器根据每一个真实服务器的状态将数据转发给一个流量比较少的服务器处理，用户也只需要记住一个域名或IP就可以了。</li><li>正向代理：正向代理主要有HTTP、HTTP over TLS(HTTPS)、Socks、Socks over TLS几种。  </li></ul><h3 id="showdowsocks"><a href="#showdowsocks" class="headerlink" title="showdowsocks"></a>showdowsocks</h3><ul><li>shadowsocks同样是一种代理协议。相对于VPN有极强的隐匿性，相对于HTTP代理有较为完善的加密方案，相较于HTTPS配置简单。  </li></ul><h2 id="二、如何使用Shadowsocks代理"><a href="#二、如何使用Shadowsocks代理" class="headerlink" title="二、如何使用Shadowsocks代理"></a>二、如何使用Shadowsocks代理</h2><ul><li>Shadowsocks作为一个翻墙利器自然不仅仅局限于Windows电脑端，还可以用于iOS, Android以Mac上  <h3 id="各平台客户端下载地址"><a href="#各平台客户端下载地址" class="headerlink" title="各平台客户端下载地址"></a>各平台客户端下载地址</h3></li><li>Android客户端(<a href="https://github.com/shadowsocks/shadowsocks-android/releases">https://github.com/shadowsocks/shadowsocks-android/releases</a>)</li><li>iOS客户端(搜索wingy)</li><li>Windows客户端(<a href="https://github.com/shadowsocks/shadowsocks-windows/releases">https://github.com/shadowsocks/shadowsocks-windows/releases</a>)</li><li>MAC客户端(<a href="https://github.com/shadowsocks/ShadowsocksX-NG/releases">https://github.com/shadowsocks/ShadowsocksX-NG/releases</a>)</li></ul><h3 id="配置描述"><a href="#配置描述" class="headerlink" title="配置描述"></a>配置描述</h3><p><img src="/img/422/peizhi.png" alt="这是图片" title="Magic Gardens"></p><ul><li>自动代理模式：表示连接国内不通过vpn，可加快访问速度</li><li>全局模式：所有连接都通过vpn</li><li>服务器：vpn的服务器配置</li><li>选择服务器，打开小飞机。即可翻墙了</li></ul><h3 id="搭建服务端代理"><a href="#搭建服务端代理" class="headerlink" title="搭建服务端代理"></a>搭建服务端代理</h3><p>服务端一键安装脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate -O shadowsocks-go.sh </span><br><span class="line">https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;poetries&#x2F;shadowsocks_install&#x2F;master&#x2F;shadowsocks-go.sh</span><br><span class="line">chmod +x shadowsocks-go.sh</span><br><span class="line">.&#x2F;shadowsocks-go.sh 2&gt;&amp;1 | tee shadowsocks-go.log </span><br></pre></td></tr></table></figure><p>安装完成后，脚本提示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Congratulations, Shadowsocks-go install completed!</span><br><span class="line">Your Server IP:your_server_ip</span><br><span class="line">Your Server Port:your_server_port</span><br><span class="line">Your Password:your_password</span><br><span class="line">Your Local Port:1080</span><br><span class="line">Your Encryption Method:aes-256-cfb</span><br><span class="line">Welcome to visit:https:&#x2F;&#x2F;teddysun.com&#x2F;392.html</span><br><span class="line">Enjoy it!  </span><br></pre></td></tr></table></figure><p>卸载方法</p><ul><li>./shadowsocks-go.sh uninstall</li></ul><h3 id="使用命令"><a href="#使用命令" class="headerlink" title="使用命令"></a>使用命令</h3><ul><li>启动：/etc/init.d/shadowsocks start</li><li>停止：/etc/init.d/shadowsocks stop</li><li>重启：/etc/init.d/shadowsocks restart</li><li>状态：/etc/init.d/shadowsocks status</li></ul><p>多用户多端口配置文件示例： 配置文件路径：/etc/shadowsocks/config.json  </p><ul><li>{<br>“port_password”:{<br>“8989”:”password0”,<br>“9001”:”password1”,<br>},<br>“method”:”aes-256-cfb”,<br>“timeout”:600<br>}</li></ul><h2 id="三、使用第三方服务"><a href="#三、使用第三方服务" class="headerlink" title="三、使用第三方服务"></a>三、使用第三方服务</h2><ul><li>自己搭建的会有被封ip的风险。推荐使用justmysocks5(<a href="https://justmysocks5.net/members/cart.php)%E5%8E%BB%E4%BB%A3%E7%90%86%EF%BC%8C%E8%BF%99%E4%BA%9B%E4%B8%80%E4%B8%AA%E6%9C%88%E4%B8%80%E4%B8%AA%E6%9C%88%E7%BB%AD%E8%B4%B9%E5%B0%B1%E5%A5%BD%EF%BC%8C%E4%B8%8D%E8%A6%81%E4%B8%80%E6%AC%A1%E6%80%A7%E4%B9%B0%E5%87%A0%E4%B8%AA%E6%9C%88%E3%80%82%E5%9B%A0%E4%B8%BA%E4%B8%8D%E7%9F%A5%E9%81%93%E6%98%AF%E4%B8%8D%E6%98%AF%E7%94%A8%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E5%B0%B1%E8%B4%B9%E5%B0%81%E4%BA%86%E3%80%82%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E8%93%9D%E7%81%AF%EF%BC%8C%E8%93%9D%E7%81%AF%E4%B8%8D%E7%A8%B3%E5%AE%9A%EF%BC%8C%E5%AE%B9%E6%98%93%E8%A2%AB%E5%B0%81%E6%9D%80%E3%80%82%E7%8E%B0%E5%9C%A8%E5%9B%BD%E5%86%85%E7%9A%84%E9%98%B2%E7%81%AB%E5%A2%99%E5%B0%81%E6%9D%80%E8%93%9D%E7%81%AF%E4%B8%80%E6%8A%93%E4%B8%80%E4%B8%AA%E5%87%86%EF%BC%8C%E5%8F%AA%E8%A6%81%E6%98%AF%E5%9B%BD%E5%86%85%E6%9C%89%E4%B8%A4%E4%BC%9A%E3%80%81%E6%88%96%E8%80%85%E5%85%B6%E4%BB%96%E6%95%8F%E6%84%9F%E6%94%BF%E6%B2%BB%E4%BA%8B%E4%BB%B6%E3%80%82%E5%9F%BA%E6%9C%AC%E4%B8%8A%E9%83%BD%E4%BC%9A%E8%A2%AB%E5%B0%81%E6%9D%80%E3%80%82">https://justmysocks5.net/members/cart.php)去代理，这些一个月一个月续费就好，不要一次性买几个月。因为不知道是不是用一段时间就费封了。不推荐使用蓝灯，蓝灯不稳定，容易被封杀。现在国内的防火墙封杀蓝灯一抓一个准，只要是国内有两会、或者其他敏感政治事件。基本上都会被封杀。</a>  </li></ul><h3 id="新建服务器进行设置"><a href="#新建服务器进行设置" class="headerlink" title="新建服务器进行设置"></a>新建服务器进行设置</h3><p><img src="/img/422/fuwuqi.png" alt="这是图片" title="Magic Gardens"></p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shadwosocks </tag>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用vercel部署</title>
      <link href="/2022/04/21/%E4%BD%BF%E7%94%A8vercel%E9%83%A8%E7%BD%B2/"/>
      <url>/2022/04/21/%E4%BD%BF%E7%94%A8vercel%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、介绍一下vercel"><a href="#一、介绍一下vercel" class="headerlink" title="一、介绍一下vercel"></a>一、介绍一下vercel</h2><ul><li><p>vercel类似于github page，但远比github page强大，速度也快得多得多，而且将Github授权给vercel后，可<br>可以达到最优雅的发布体验，只需将代码轻轻一推，项目就自动更新部署了。</p></li><li><p>vercel还支持部署serverless接口。那代表着，其不仅仅可以部署静态网站，甚至可以部署动态网站，而这些功能<br>能，统统都是免费的。</p></li><li><p>vercel还支持自动配置https，不用自己去FreeSSL申请证书，更是省去了一大堆证书的配置</p></li><li><p>vercel目前的部署模板有31种之多</p><p><img src="/img/421/selectTemplate.png" alt="这是图片" title="Magic Gardens"></p><span id="more"></span></li></ul><h2 id="二、起步"><a href="#二、起步" class="headerlink" title="二、起步"></a>二、起步</h2><ul><li><p>打开vercel主页<a href="https://vercel.com/signup">https://vercel.com/signup</a>  </p></li><li><p>使用GitHub账号去关联vercel，后续代码提交到vercel可以自动触发部署  </p></li><li><p>出现授权页面，点击Authorize Vercel。</p><h2 id="三、部署Hexo博客"><a href="#三、部署Hexo博客" class="headerlink" title="三、部署Hexo博客"></a>三、部署Hexo博客</h2><p>vercel是最好用的静态站点托管平台，借助vercel平台，我们可以把博客静态文件部署到vercel上，不在使用<br>GitHub pages托管，vercel比GitHub pages快多了。</p></li><li><p>选择一个vercel提供的模板部署，当然你也可以把代码提交到GitHub上，再去vercel选择即可</p><p><img src="/img/421/select1.png" alt="这是图片" title="Magic Gardens"></p></li><li><p>创建一个GitHub项目，代码会自动在GitHub账号上创建<br><img src="/img/421/creat1.png" alt="这是图片" title="Magic Gardens"></p></li><li><p>创建完成后，等待vercel构建<br><img src="/img/421/deploy1.png" alt="这是图片" title="Magic Gardens"></p></li><li><p>创建成功后自动跳到主页<br><img src="/img/421/success1.png" alt="这是图片" title="Magic Gardens"></p></li><li><p>点击visit即可访问创建好的服务，vercel会分配给我们一个默认的域名，当然你也可以自定义修改。<br><img src="/img/421/index1.png" alt="这是图片" title="Magic Gardens"></p></li><li><p>你也可以从Github选择代码来创建项目<br><img src="/img/421/import1.png" alt="这是图片" title="Magic Gardens"></p></li><li><p>导入GitHub账号上的项目<br><img src="/img/421/import2.png" alt="这是图片" title="Magic Gardens"></p></li></ul><p>部署vue、react等前端项目过程也类似，这里不再演示</p><h2 id="四、部署serverless接口"><a href="#四、部署serverless接口" class="headerlink" title="四、部署serverless接口"></a>四、部署serverless接口</h2><ul><li>因为暂时没有部署动态网站的需求所以没有使用，具体使用方法请自行百度。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vercel </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
